<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>塔台工程二维模拟</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --panel: #ffffff;
      --stick: #9b6b3d;
      --stick-highlight: #be8551;
      --danger: #c0392b;
      --ok: #2d8a4f;
      --muted: #6c7a96;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
      background: var(--bg);
      color: #1f2a44;
      display: grid;
      grid-template-columns: 340px 1fr;
      min-height: 100vh;
      gap: 12px;
      padding: 12px;
    }
    .panel {
      background: var(--panel);
      border-radius: 12px;
      box-shadow: 0 3px 12px rgba(0,0,0,0.08);
      padding: 14px;
    }
    .panel h1 { font-size: 20px; margin: 0 0 10px; }
    .section { margin-bottom: 14px; }
    .section h2 { font-size: 15px; margin: 0 0 8px; color: #304167; }
    .row { display: flex; align-items: center; gap: 8px; margin: 7px 0; }
    .row label { width: 98px; color: #3f4f74; font-size: 13px; }
    input[type="range"] { flex: 1; }
    input[type="number"] { width: 64px; padding: 4px; }
    button {
      border: none;
      background: #4361ee;
      color: white;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }
    button.secondary { background: #7b879f; }
    button.danger { background: #d94841; }
    .stats {
      background: #f2f5ff;
      border-radius: 8px;
      padding: 10px;
      font-size: 14px;
      line-height: 1.7;
    }
    .stats strong { color: #20315a; }
    .ok { color: var(--ok); }
    .danger-text { color: var(--danger); }
    .hint { font-size: 12px; color: var(--muted); line-height: 1.5; }
    .canvas-wrap {
      background: var(--panel);
      border-radius: 12px;
      box-shadow: 0 3px 12px rgba(0,0,0,0.08);
      padding: 8px;
      display: flex;
      flex-direction: column;
    }
    canvas {
      width: 100%;
      height: calc(100vh - 50px);
      border-radius: 10px;
      background: linear-gradient(#f9fbff, #eef3ff 70%);
      border: 1px solid #d9e1f2;
      cursor: crosshair;
    }
    @media (max-width: 980px) {
      body { grid-template-columns: 1fr; }
      canvas { height: 62vh; }
    }
  </style>
</head>
<body>
  <aside class="panel">
    <h1>塔台工程互动模拟</h1>
    <div class="section">
      <h2>搭建工具</h2>
      <div class="row">
        <label>木条长度(px)</label>
        <input type="range" id="stickLength" min="35" max="140" value="78" />
        <span id="stickLengthVal">78</span>
      </div>
      <div class="row">
        <label>木条单价(元)</label>
        <input type="number" id="stickCost" min="1" max="50" value="6" />
      </div>
      <div class="row">
        <button id="undoBtn" class="secondary">撤销一步</button>
        <button id="clearBtn" class="danger">清空重建</button>
      </div>
      <p class="hint" id="buildHint">先在地面点击建立支点，再从已有节点拖拽搭建。不能直接在空中单独放点。</p>
    </div>

    <div class="section">
      <h2>环境测试</h2>
      <div class="row">
        <label>顶部重物(kg)</label>
        <input type="range" id="load" min="0" max="220" value="20" />
        <span id="loadVal">20</span>
      </div>
      <div class="row">
        <label>风力等级</label>
        <input type="range" id="wind" min="0" max="12" value="1" />
        <span id="windVal">1</span>
      </div>
      <div class="row">
        <label>地震强度</label>
        <input type="range" id="quake" min="0" max="10" value="0" />
        <span id="quakeVal">0</span>
      </div>
      <div class="row">
        <button id="testBtn">开始检验</button>
        <button id="pauseBtn" class="secondary">暂停扰动</button>
      </div>
    </div>

    <div class="section">
      <h2>实时数据</h2>
      <div class="stats">
        <div>木条数量：<strong id="sticksCount">0</strong></div>
        <div>塔台高度：<strong id="heightVal">0.00 m</strong></div>
        <div>总造价：<strong id="costVal">0 元</strong></div>
        <div>稳定评分：<strong id="stabilityVal">100</strong></div>
        <div>安全状态：<strong id="statusVal" class="ok">稳固</strong></div>
      </div>
    </div>
  </aside>

  <main class="canvas-wrap">
    <canvas id="simCanvas" width="1100" height="760"></canvas>
  </main>

  <script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');
    const baseY = () => canvas.height - 60;

    const nodes = [];
    const sticks = [];
    const history = [];
    let dragFrom = null;
    let mouseX = 0;
    let mouseY = 0;
    let testing = false;
    let time = 0;

    const ui = {
      stickLength: document.getElementById('stickLength'),
      stickLengthVal: document.getElementById('stickLengthVal'),
      stickCost: document.getElementById('stickCost'),
      load: document.getElementById('load'),
      loadVal: document.getElementById('loadVal'),
      wind: document.getElementById('wind'),
      windVal: document.getElementById('windVal'),
      quake: document.getElementById('quake'),
      quakeVal: document.getElementById('quakeVal'),
      sticksCount: document.getElementById('sticksCount'),
      heightVal: document.getElementById('heightVal'),
      costVal: document.getElementById('costVal'),
      stabilityVal: document.getElementById('stabilityVal'),
      statusVal: document.getElementById('statusVal'),
      buildHint: document.getElementById('buildHint')
    };

    const syncLabels = () => {
      ui.stickLengthVal.textContent = ui.stickLength.value;
      ui.loadVal.textContent = ui.load.value;
      ui.windVal.textContent = ui.wind.value;
      ui.quakeVal.textContent = ui.quake.value;
    };
    ['input', 'change'].forEach(evt => {
      ui.stickLength.addEventListener(evt, syncLabels);
      ui.load.addEventListener(evt, syncLabels);
      ui.wind.addEventListener(evt, syncLabels);
      ui.quake.addEventListener(evt, syncLabels);
    });
    syncLabels();

    const dist = (a, b) => Math.hypot(a.x - b.x, a.y - b.y);

    function nearestNode(x, y, max = 14) {
      let best = null;
      let bestD = max;
      for (const n of nodes) {
        const d = Math.hypot(n.x - x, n.y - y);
        if (d < bestD) { best = n; bestD = d; }
      }
      return best;
    }

    function createNode(x, y, fixed = false) {
      const node = { x, y, vx: 0, vy: 0, fixed };
      nodes.push(node);
      history.push({ type: 'node', node });
      return node;
    }

    function hasStick(a, b) {
      return sticks.some(s => (s.a === a && s.b === b) || (s.a === b && s.b === a));
    }

    function createStick(a, b) {
      if (!a || !b || a === b || hasStick(a, b)) return;
      sticks.push({ a, b, rest: dist(a, b), broken: false });
      history.push({ type: 'stick' });
    }

    function undo() {
      const h = history.pop();
      if (!h) return;
      if (h.type === 'stick') {
        sticks.pop();
      } else {
        const removed = nodes.pop();
        for (let i = sticks.length - 1; i >= 0; i--) {
          if (sticks[i].a === removed || sticks[i].b === removed) sticks.splice(i, 1);
        }
      }
      updateStats();
    }

    function clearAll() {
      nodes.length = 0;
      sticks.length = 0;
      history.length = 0;
      testing = false;
      ui.buildHint.textContent = '先在地面点击建立支点，再从已有节点拖拽搭建。不能直接在空中单独放点。';
      updateStats();
    }

    function calculateHeightPx() {
      const attached = nodes.filter(n => n.y < baseY() + 1);
      if (!attached.length) return 0;
      return Math.max(0, baseY() - Math.min(...attached.map(n => n.y)));
    }

    function computeStability() {
      const load = Number(ui.load.value);
      const wind = Number(ui.wind.value);
      const quake = Number(ui.quake.value);
      const h = calculateHeightPx();
      const supportNodes = nodes.filter(n => n.fixed).length;
      const baseXs = nodes.filter(n => n.fixed).map(n => n.x);
      const baseWidth = baseXs.length > 1 ? Math.max(...baseXs) - Math.min(...baseXs) : 25;
      const triangleLike = sticks.length > 0 ? sticks.length / Math.max(1, nodes.length - 1) : 0;
      const brokenCount = sticks.filter(s => s.broken).length;

      let score = 100;
      score -= h * 0.11 + load * 0.18 + wind * 4.5 + quake * 6.3;
      score += Math.min(28, baseWidth * 0.09) + Math.min(20, supportNodes * 4) + Math.min(18, triangleLike * 10);
      score -= brokenCount * 20;
      return Math.max(0, Math.min(100, score));
    }

    function updateStats() {
      const hMeters = (calculateHeightPx() / 85).toFixed(2);
      const totalCost = sticks.length * Math.max(1, Number(ui.stickCost.value) || 0);
      const stability = computeStability();
      ui.sticksCount.textContent = String(sticks.length);
      ui.heightVal.textContent = `${hMeters} m`;
      ui.costVal.textContent = `${totalCost} 元`;
      ui.stabilityVal.textContent = stability.toFixed(0);

      let status = '稳固';
      let cls = 'ok';
      if (stability < 70) { status = '轻微晃动'; cls = 'danger-text'; }
      if (stability < 45) { status = '高风险'; cls = 'danger-text'; }
      if (stability < 25) { status = '正在倒塌'; cls = 'danger-text'; }
      ui.statusVal.textContent = status;
      ui.statusVal.className = cls;
    }

    function getTopNode() {
      if (!nodes.length) return null;
      return nodes.reduce((a, b) => b.y < a.y ? b : a);
    }

    function physicsStep() {
      const gravity = 0.25;
      const wind = Number(ui.wind.value);
      const quake = Number(ui.quake.value);
      const load = Number(ui.load.value);

      for (const n of nodes) {
        if (n.fixed) continue;
        let fx = 0;
        let fy = gravity;
        if (testing) {
          fx += Math.sin(time * 0.03) * wind * 0.04;
          fx += Math.sin(time * 0.14) * quake * 0.08;
        }
        n.vx = (n.vx + fx) * 0.994;
        n.vy = (n.vy + fy) * 0.994;
      }

      const top = getTopNode();
      if (testing && top && !top.fixed) {
        top.vy += load * 0.0015;
      }

      for (let k = 0; k < 4; k++) {
        for (let i = sticks.length - 1; i >= 0; i--) {
          const s = sticks[i];
          const dx = s.b.x - s.a.x;
          const dy = s.b.y - s.a.y;
          const d = Math.hypot(dx, dy) || 0.001;
          const diff = (d - s.rest) / d;
          const strain = Math.abs(d - s.rest) / s.rest;
          const breakLimit = 0.42 - (Number(ui.load.value) * 0.0005);
          if (testing && strain > breakLimit) {
            sticks.splice(i, 1);
            continue;
          }

          const pushX = dx * diff * 0.5;
          const pushY = dy * diff * 0.5;
          if (!s.a.fixed) { s.a.x += pushX; s.a.y += pushY; }
          if (!s.b.fixed) { s.b.x -= pushX; s.b.y -= pushY; }
        }
      }

      for (const n of nodes) {
        if (!n.fixed) {
          n.x += n.vx;
          n.y += n.vy;
          if (n.y > baseY()) {
            n.y = baseY();
            n.vy *= -0.15;
            n.vx *= 0.85;
          }
        }
      }
    }

    function drawGround() {
      ctx.fillStyle = '#dce8ff';
      ctx.fillRect(40, baseY(), canvas.width - 80, 22);
      ctx.strokeStyle = '#95a4c8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(40, baseY());
      ctx.lineTo(canvas.width - 40, baseY());
      ctx.stroke();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (testing || nodes.some(n => !n.fixed)) physicsStep();

      drawGround();

      for (const s of sticks) {
        const stretch = Math.abs(dist(s.a, s.b) - s.rest) / s.rest;
        ctx.strokeStyle = stretch > 0.2 ? '#d64747' : '#9b6b3d';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(s.a.x, s.a.y);
        ctx.lineTo(s.b.x, s.b.y);
        ctx.stroke();

        ctx.strokeStyle = '#be8551';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(s.a.x, s.a.y);
        ctx.lineTo(s.b.x, s.b.y);
        ctx.stroke();
      }

      for (const n of nodes) {
        ctx.fillStyle = n.fixed ? '#1b7f43' : '#26355d';
        ctx.beginPath();
        ctx.arc(n.x, n.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      if (dragFrom) {
        const len = Number(ui.stickLength.value);
        const a = Math.atan2(mouseY - dragFrom.y, mouseX - dragFrom.x);
        const tx = dragFrom.x + Math.cos(a) * len;
        const ty = dragFrom.y + Math.sin(a) * len;
        ctx.setLineDash([7, 7]);
        ctx.strokeStyle = '#4e6fca';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(dragFrom.x, dragFrom.y);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      const top = getTopNode();
      if (top && Number(ui.load.value) > 0) {
        const load = Number(ui.load.value);
        const w = 22 + Math.min(52, load * 0.18);
        const h = 16 + Math.min(32, load * 0.1);
        ctx.fillStyle = '#444';
        ctx.fillRect(top.x - w / 2, top.y - h - 5, w, h);
        ctx.fillStyle = '#f7f7f7';
        ctx.font = '12px sans-serif';
        ctx.fillText(`${load}kg`, top.x - w / 2 + 4, top.y - 12);
      }

      if (testing && computeStability() < 20 && sticks.length === 0 && nodes.length > 0) {
        ctx.fillStyle = 'rgba(205, 49, 49, 0.17)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        ui.buildHint.textContent = '结构已倒塌：木条全部断裂。请加宽底座并增加三角支撑。';
      }

      updateStats();
      time += 1;
      requestAnimationFrame(draw);
    }

    canvas.addEventListener('mousemove', e => {
      const r = canvas.getBoundingClientRect();
      mouseX = (e.clientX - r.left) * (canvas.width / r.width);
      mouseY = (e.clientY - r.top) * (canvas.height / r.height);
    });

    canvas.addEventListener('mousedown', e => {
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top) * (canvas.height / r.height);
      const near = nearestNode(x, y, 14);

      if (near) {
        dragFrom = near;
        return;
      }

      if (Math.abs(y - baseY()) <= 14) {
        createNode(x, baseY(), true);
        ui.buildHint.textContent = '已添加地面支点，继续从节点拖拽搭建。';
      } else {
        ui.buildHint.textContent = '不能在空中直接放点：请先点击地面，或从已有节点拖拽生成新节点。';
      }
      updateStats();
    });

    canvas.addEventListener('mouseup', e => {
      if (!dragFrom) return;
      const r = canvas.getBoundingClientRect();
      const x = (e.clientX - r.left) * (canvas.width / r.width);
      const y = (e.clientY - r.top) * (canvas.height / r.height);
      const len = Number(ui.stickLength.value);

      let target = nearestNode(x, y, 14);
      if (!target) {
        const a = Math.atan2(y - dragFrom.y, x - dragFrom.x);
        const nx = dragFrom.x + Math.cos(a) * len;
        const nyRaw = dragFrom.y + Math.sin(a) * len;
        const ny = Math.min(baseY(), nyRaw);
        const fixed = Math.abs(ny - baseY()) < 2;
        target = createNode(nx, ny, fixed);
      }

      createStick(dragFrom, target);
      dragFrom = null;
      ui.buildHint.textContent = '已连接木条。可调重物、风、地震后点击“开始检验”。';
      updateStats();
    });

    document.getElementById('testBtn').addEventListener('click', () => {
      testing = true;
      ui.buildHint.textContent = '检验中：观察是否发生形变、断裂与倒塌。';
    });
    document.getElementById('pauseBtn').addEventListener('click', () => {
      testing = false;
      ui.buildHint.textContent = '已暂停扰动。可继续搭建后再次检验。';
    });
    document.getElementById('undoBtn').addEventListener('click', undo);
    document.getElementById('clearBtn').addEventListener('click', clearAll);

    draw();
  </script>
</body>
</html>
