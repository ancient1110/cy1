<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å…­å¹´çº§ç§‘å­¦ï¼šå¡”å°å·¥ç¨‹ v7.1 (å®Œç¾ç‰©ç†+æ–­è£‚å¤ç›˜) Â· ç°ä»£UI</title>
    <style>
        /* === ç•Œé¢æ ·å¼ä¿æŒä¸å˜ === */
        body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; margin: 0; overflow: hidden; background-color: #f0f2f5; display: flex; user-select: none; }
        
        #canvas-container {
            flex-grow: 1; height: 100vh; position: relative;
            background: radial-gradient(circle at center, #ffffff 0%, #eef2f3 100%);
            cursor: crosshair;
        }

        #sidebar {
            width: 320px; height: 100vh; background: #fff;
            border-left: 1px solid #dcdcdc; display: flex; flex-direction: column;
            box-shadow: -5px 0 15px rgba(0,0,0,0.05); z-index: 100;
        }

        .sidebar-scroll { padding: 12px 14px; overflow-y: auto; flex-grow: 1; }

        h2 { font-size: 14px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 5px; margin: 12px 0 8px 0; display: flex; justify-content: space-between; align-items: center; }
        h2:first-child { margin-top: 0; }
        
        .mode-btn {
            width: 100%; padding: 11px; border: none; border-radius: 8px;
            font-size: 16px; font-weight: bold; cursor: pointer; color: white;
            transition: all 0.3s; margin-bottom: 12px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.3);
        }
        .mode-btn.testing {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
        }
        .mode-btn:active { transform: scale(0.98); }

        .material-group { display: flex; gap: 8px; margin-bottom: 10px; }
        .mat-option {
            flex: 1; padding: 8px 4px; border: 2px solid #ecf0f1; border-radius: 6px;
            text-align: center; cursor: pointer; transition: all 0.2s; font-size: 11px;
            background: #f9f9f9;
        }
        .mat-option:hover { border-color: #bdc3c7; }
        .mat-option.active { border-color: #3498db; background: #ebf5fb; color: #2980b9; font-weight: bold; }
        .mat-color { width: 12px; height: 12px; border-radius: 50%; margin: 0 auto 5px; }

        .slider-group { margin-bottom: 8px; background: #f8f9fa; padding: 7px 8px; border-radius: 6px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 4px; color: #555; }
        input[type=range] { width: 100%; cursor: pointer; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; color: #555; }
        .total-cost { display:flex; justify-content: space-between; align-items: baseline; font-size: 20px; color: #e67e22; font-weight: bold; margin-top: 6px; }
        
        #toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.85); color: white; padding: 8px 20px;
            border-radius: 30px; opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        
        .btn-group { display: flex; gap: 8px; margin-top: 10px; }
        .btn-small {
            background: #ecf0f1; border: none; padding: 7px 0; border-radius: 4px;
            cursor: pointer; color: #7f8c8d; font-size: 12px; flex: 1;
        }
        .btn-small:hover { background: #ffeaa7; color: #d35400; }
        .btn-small.danger { background: #fde6e6; color: #c0392b; }
        .btn-small.danger:hover { background: #f5b7b1; }

        #delete-mode-toggle {
            background: #ecf0f1; border: 2px solid #bdc3c7; border-radius: 4px;
            padding: 7px; text-align: center; cursor: pointer; font-size: 12px; margin-top: 8px;
        }
        #delete-mode-toggle.active {
            background: #e74c3c; border-color: #c0392b; color: white;
        }

        .btn-special {
            background: #3498db; color: white; width: 100%; padding: 8px;
            border: none; border-radius: 4px; margin-top: 15px; cursor: pointer;
            font-size: 14px;
        }
        .btn-special:hover { background: #2980b9; }

        #height-indicator {
            position: absolute; top: 12px; left: 14px;
            background: rgba(255,255,255,0.92); color: #2c3e50;
            border: 1px solid #d5dadd; border-radius: 10px;
            padding: 8px 12px; box-shadow: 0 4px 10px rgba(0,0,0,0.08);
            font-size: 14px; font-weight: 600;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
        <div id="toast">æç¤ºä¿¡æ¯</div>
        <div id="height-indicator">ğŸ”ï¸ æœ€é«˜ç‚¹ï¼š0 cm</div>
    </div>

    <div id="sidebar">
        <div class="sidebar-scroll">
            <button id="btn-mode" class="mode-btn" onclick="toggleSimulation()">â–¶ï¸ å¼€å§‹æµ‹è¯•</button>

            <h2>ğŸ—ï¸ ææ–™é€‰æ‹© (ç‚¹å‡»åˆ‡æ¢)</h2>
            <div class="material-group">
                <div class="mat-option active" onclick="setMaterial('wood')" id="mat-wood">
                    <div class="mat-color" style="background:#8e44ad"></div>
                    <div>æ™®é€šæœ¨æ¡<br>Â¥2/cm</div>
                </div>
                <div class="mat-option" onclick="setMaterial('steel')" id="mat-steel">
                    <div class="mat-color" style="background:#2c3e50"></div>
                    <div>åŠ å¼ºé’¢æ<br>Â¥8/cm</div>
                </div>
                <div class="mat-option" onclick="setMaterial('carbon')" id="mat-carbon">
                    <div class="mat-color" style="background:#2980b9"></div>
                    <div>ç¢³çº¤ç»´<br>Â¥20/cm</div>
                </div>
            </div>
            <div style="font-size:12px; color:#7f8c8d; margin-top:5px;">
                * å½“å‰é€‰æ‹©ææ–™å°†ç”¨äºæ–°å»ºçš„æœ¨æ¡å’ŒèŠ‚ç‚¹ã€‚
            </div>

            <h2>ğŸ›ï¸ ç¯å¢ƒæµ‹è¯•å°</h2>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸ’¨ é£åŠ›ç­‰çº§</span> <span id="val-wind">0çº§</span></div>
                <input type="range" min="0" max="100" value="0" oninput="updateEnv('wind', this.value)" disabled id="slider-wind">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸŒ‹ åœ°éœ‡å¼ºåº¦</span> <span id="val-quake">0çº§</span></div>
                <input type="range" min="0" max="100" value="0" oninput="updateEnv('quake', this.value)" disabled id="slider-quake">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>âš–ï¸ é¡¶éƒ¨å‹é‡</span> <span id="val-load">0kg</span></div>
                <input type="range" min="0" max="100" value="0" oninput="updateEnv('load', this.value)" disabled id="slider-load">
            </div>

            <h2>ğŸ“Š å·¥ç¨‹é€ ä»·å•</h2>
            <div class="stat-row"><span>èŠ‚ç‚¹æ•°é‡:</span> <span id="stat-nodes">0</span> Ã— Â¥50</div>
            <div class="stat-row"><span>æ†ä»¶æ€»é•¿:</span> <span id="stat-total-length">0 cm</span></div>
            <div class="stat-row"><span>æœ¨æ¡é•¿åº¦:</span> <span id="stat-len-wood">0 cm</span> (Â¥2/cm)</div>
            <div class="stat-row"><span>é’¢æé•¿åº¦:</span> <span id="stat-len-steel">0 cm</span> (Â¥8/cm)</div>
            <div class="stat-row"><span>ç¢³çº¤é•¿åº¦:</span> <span id="stat-len-carbon">0 cm</span> (Â¥20/cm)</div>
            <div class="total-cost"><span>æ€»ä»·:</span><span>Â¥<span id="stat-cost">0</span></span></div>

            <div style="display: flex; gap: 8px; margin: 20px 0 10px;">
                <button class="btn-small" onclick="undo()">â†©ï¸ æ’¤é”€</button>
                <button class="btn-small danger" onclick="clearAll()">ğŸ—‘ï¸ å…¨éƒ¨æ¸…ç©º</button>
            </div>
            <div id="delete-mode-toggle" onclick="toggleDeleteMode()">âœ‚ï¸ åˆ é™¤æ¨¡å¼ (å…³é—­)</div>
            
            <button class="btn-special" onclick="autoConnectIntersections()">ğŸ”— è‡ªåŠ¨è¿æ¥äº¤å‰ç‚¹</button>
        </div>
    </div>

<script>
    (function() {
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // --- å…¨å±€è®¡æ•°å™¨ï¼Œç”¨äºè¿½è¸ªå¯¹è±¡ID (æ ¸å¿ƒï¼šç”¨äºå¤ç›˜) ---
        let globalIdCounter = 0;
        function getUniqueId() { return globalIdCounter++; }

        const MATERIALS = {
            wood:   { id: 'wood',   name: 'æœ¨æ¡', color: '#8e44ad', cost: 2,  strength: 15,  nodeStrength: 40,  mass: 0.1, angleStrength: 0.10 },
            steel:  { id: 'steel',  name: 'é’¢æ', color: '#2c3e50', cost: 8,  strength: 60,  nodeStrength: 120, mass: 0.3, angleStrength: 0.35 },
            carbon: { id: 'carbon', name: 'ç¢³çº¤', color: '#2980b9', cost: 20, strength: 100, nodeStrength: 180, mass: 0.05, angleStrength: 0.50 }
        };

        const CONFIG = {
            gravity: 2.0,      // ç¡¬æ ¸é‡åŠ›
            groundHeight: 60,
            snapDist: 15,
            maxStickLen: 120,
            scale: 10,
            nodeBaseCost: 50,
            angleStiffness: 0.1,
            angleIterations: 3,
            minPointMass: 0.05,
            nodeMassFactor: 4,
            loadForceScale: 0.22,
            windForceScale: 1.6,
            quakeForceScale: 0.8
        };

        // --- ç¢ç‰‡ç‰¹æ•ˆç³»ç»Ÿ ---
        class Fragment {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8 - 2;
                this.life = 1.0;
                this.color = color;
                this.size = Math.random() * 3 + 2;
            }
            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.5;
                this.life -= 0.02;
            }
            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.fillRect(this.x, this.y, this.size, this.size);
                ctx.globalAlpha = 1.0;
            }
        }
        let fragments = [];
        function createExplosion(x, y, color) {
            for(let i=0; i<8; i++) {
                fragments.push(new Fragment(x, y, color));
            }
        }

        // --- å…¨å±€å˜é‡ ---
        let width, height, groundY;
        let points = [];
        let sticks = [];
        let isSimulating = false;
        let statsLocked = false;
        let currentMat = 'wood';
        let blueprint = null;
        let env = { wind: 0, quake: 0, load: 0 };
        let mouse = { x: 0, y: 0 };
        let dragStart = null;
        let isDragging = false;
        let hoveredPoint = null;
        let hoveredStick = null;
        let preheatRemaining = 0;
        let angleConstraints = [];
        let historyStack = [];
        const MAX_HISTORY = 20;
        let deleteMode = false;

        // --- æ–­è£‚æ—¥å¿— (ç”¨äºå¤åŸåé«˜äº®) ---
        let breakLog = []; 
        let nextBreakOrder = 1;

        function getWindForceAtY(y) {
            if (!isSimulating || env.wind <= 0) return 0;
            const amplitude = (groundY - y) / 1000 * (env.wind / 20);
            const phase = Date.now() / 350;
            return Math.sin(phase) * amplitude;
        }

        function getQuakeOffsets() {
            if (!isSimulating || env.quake <= 0) return { x: 0, y: 0 };
            const t = Date.now();
            const xAmp = env.quake / 5;
            const yAmp = env.quake / 8;
            return {
                x: Math.sin(t / 50) * xAmp,
                y: Math.cos(t / 65) * yAmp
            };
        }

        function getQuakeForce() {
            if (!isSimulating || env.quake <= 0) return { x: 0, y: 0 };
            const t = Date.now();
            return {
                x: Math.sin(t / 42) * env.quake * CONFIG.quakeForceScale,
                y: Math.cos(t / 58) * env.quake * CONFIG.quakeForceScale * 0.45
            };
        }

        function getPointMass(point) {
            return Math.max(CONFIG.minPointMass, point.dynamicMass || (point.mat.mass * CONFIG.nodeMassFactor));
        }

        function refreshPointMasses() {
            points.forEach(p => {
                p.dynamicMass = Math.max(CONFIG.minPointMass, p.mat.mass * CONFIG.nodeMassFactor);
            });

            sticks.forEach(s => {
                if (s.broken) return;
                const stickMass = (s.len / CONFIG.scale) * s.mat.mass;
                const halfMass = stickMass * 0.5;
                s.p1.dynamicMass += halfMass;
                s.p2.dynamicMass += halfMass;
            });
        }

        // --- Point ç±» ---
        class Point {
            constructor(x, y, pinned, matId, uid = null) {
                this.x = x; this.y = y;
                this.oldx = x; this.oldy = y;
                this.pinned = pinned;
                this.mat = MATERIALS[matId];
                this.baseX = x;
                this.broken = false; 
                this.simId = uid !== null ? uid : getUniqueId(); // å”¯ä¸€IDï¼Œç”¨äºè·¨æ¨¡æ‹Ÿ/ç¼–è¾‘è¿½è¸ª
                this.dynamicMass = Math.max(CONFIG.minPointMass, this.mat.mass * CONFIG.nodeMassFactor);
                
                // å¤ç›˜å±æ€§
                this.wasBroken = false;
                this.breakOrder = 0;
            }

            update() {
                if (!isSimulating) {
                    this.oldx = this.x;
                    this.oldy = this.y;
                    return;
                }

                if (this.pinned) {
                    const quake = getQuakeOffsets();
                    if (env.quake > 0) {
                        this.x = this.baseX + quake.x;
                        this.y = groundY + quake.y;
                    } else {
                        this.x += (this.baseX - this.x) * 0.1;
                        this.y = groundY;
                    }
                    this.oldx = this.x;
                    this.oldy = this.y;
                    return;
                }

                let vx = (this.x - this.oldx) * 0.98;
                let vy = (this.y - this.oldy) * 0.98;
                const invMass = 1 / getPointMass(this);
                const quakeForce = getQuakeForce();

                this.oldx = this.x;
                this.oldy = this.y;

                this.y += CONFIG.gravity;

                if (groundY - this.y > 100) {
                    this.y += env.load * CONFIG.loadForceScale * invMass;
                }

                this.x += getWindForceAtY(this.y) * CONFIG.windForceScale * invMass;
                this.x += quakeForce.x * invMass;
                this.y += quakeForce.y * invMass;

                this.x += vx;
                this.y += vy;

                if (this.y > groundY) {
                    this.y = groundY;
                    this.oldy = this.y + vy * 0.5;
                }
            }
        }

        // --- Stick ç±» ---
        class Stick {
            constructor(p1, p2, matId, uid = null) {
                this.p1 = p1;
                this.p2 = p2;
                this.mat = MATERIALS[matId];
                this.len = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                this.stress = 0;
                this.broken = false;
                this.simId = uid !== null ? uid : getUniqueId();

                // å¤ç›˜å±æ€§
                this.wasBroken = false;
                this.breakOrder = 0;
            }

            update() {
                if (this.broken) return;

                if (!isSimulating) {
                    this.len = Math.hypot(this.p1.x - this.p2.x, this.p1.y - this.p2.y);
                    return;
                }

                let dx = this.p2.x - this.p1.x;
                let dy = this.p2.y - this.p1.y;
                let dist = Math.hypot(dx, dy);
                if (dist === 0) return;

                this.stress = Math.abs(dist - this.len);

                if (preheatRemaining <= 0) {
                    // æ†ä»¶å¼ºåº¦æ–­è£‚
                    if (this.stress > this.mat.strength) {
                        this.broken = true;
                    }
                    // èŠ‚ç‚¹å¼ºåº¦æ–­è£‚ (æ‹‰åŠ›ç ´å) - æ ‡è®°èŠ‚ç‚¹ä¸ºbrokenï¼Œåœ¨loopä¸­ç»Ÿä¸€å¤„ç†
                    if (this.stress > Math.min(this.p1.mat.nodeStrength, this.p2.mat.nodeStrength)) {
                        if (this.p1.mat.nodeStrength < this.stress && !this.p1.pinned) this.p1.broken = true;
                        if (this.p2.mat.nodeStrength < this.stress && !this.p2.pinned) this.p2.broken = true;
                    }
                }

                const w1 = this.p1.pinned ? 0 : 1 / getPointMass(this.p1);
                const w2 = this.p2.pinned ? 0 : 1 / getPointMass(this.p2);
                const totalW = w1 + w2;
                if (totalW <= 0) return;

                const correctionRatio = (dist - this.len) / dist;
                const corrX = dx * correctionRatio;
                const corrY = dy * correctionRatio;

                if (!this.p1.pinned) {
                    const share = w1 / totalW;
                    this.p1.x += corrX * share;
                    this.p1.y += corrY * share;
                }
                if (!this.p2.pinned) {
                    const share = w2 / totalW;
                    this.p2.x -= corrX * share;
                    this.p2.y -= corrY * share;
                }
            }

            draw() {
                if (isSimulating && this.broken) return; // æ¨¡æ‹Ÿä¸­æ–­è£‚ä¸ç»˜åˆ¶

                ctx.beginPath();
                
                // å¤ç›˜æ¨¡å¼ï¼šå¦‚æœæ˜¯æœ€å…ˆæ–­çš„3ä¸ªï¼Œé«˜äº®æ˜¾ç¤º
                if (!isSimulating && this.wasBroken && this.breakOrder > 0 && this.breakOrder <= 3) {
                    ctx.strokeStyle = '#e74c3c'; // çº¢
                    ctx.lineWidth = 6;
                    ctx.moveTo(this.p1.x, this.p1.y);
                    ctx.lineTo(this.p2.x, this.p2.y);
                    ctx.stroke();
                    // è¦†ç›–ä¸€å±‚åŸè‰²
                    ctx.strokeStyle = this.mat.color;
                    ctx.lineWidth = 2;
                    ctx.moveTo(this.p1.x, this.p1.y);
                    ctx.lineTo(this.p2.x, this.p2.y);
                    ctx.stroke();
                    return;
                }

                // æ­£å¸¸ç»˜åˆ¶
                let color = this.mat.color;
                if (isSimulating) {
                    let ratio = Math.min(this.stress / (this.mat.strength * 0.8), 1);
                    if (ratio > 0.5) {
                        ctx.strokeStyle = `rgb(255, ${200 * (1-ratio)}, 0)`;
                    } else {
                        ctx.strokeStyle = color;
                    }
                } else {
                    ctx.strokeStyle = color;
                }

                ctx.lineWidth = 4;
                ctx.lineCap = 'round';
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
            }
        }

        function init() {
            resize();
            window.addEventListener('resize', resize);
            addPoint(width/2 - 60, groundY, true, 'wood');
            addPoint(width/2 + 60, groundY, true, 'wood');
            saveHistory();
            loop();
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            groundY = height - CONFIG.groundHeight;
            points.forEach(p => { if(p.pinned) p.y = groundY; });
        }

        function addPoint(x, y, pinned, matId, uid = null) {
            let p = new Point(x, y, pinned, matId, uid);
            points.push(p);
            return p;
        }

        function saveHistory() {
            let snapshot = {
                points: points.map(p => ({
                    x: p.x, y: p.y, pinned: p.pinned, matId: p.mat.id, uid: p.simId
                })),
                sticks: sticks.map(s => {
                    let p1Idx = points.indexOf(s.p1);
                    let p2Idx = points.indexOf(s.p2);
                    return { p1Idx, p2Idx, matId: s.mat.id, uid: s.simId };
                })
            };
            historyStack.push(snapshot);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
        }

        function restoreFromHistory(snapshot) {
            points = snapshot.points.map(p => new Point(p.x, p.y, p.pinned, p.matId, p.uid));
            sticks = snapshot.sticks.map(s => {
                let p1 = points[s.p1Idx];
                let p2 = points[s.p2Idx];
                return new Stick(p1, p2, s.matId, s.uid);
            });
            angleConstraints = [];
        }

        function undo() {
            if (isSimulating) { showToast("æµ‹è¯•ä¸­ä¸èƒ½æ’¤é”€"); return; }
            if (historyStack.length <= 1) { showToast("æ²¡æœ‰æ›´å¤šæ­¥éª¤"); return; }
            historyStack.pop();
            let prev = historyStack[historyStack.length-1];
            restoreFromHistory(prev);
            showToast("æ’¤é”€æˆåŠŸ");
        }

        function toggleDeleteMode() {
            if (isSimulating) { showToast("æµ‹è¯•ä¸­ä¸èƒ½åˆ é™¤"); return; }
            deleteMode = !deleteMode;
            document.getElementById('delete-mode-toggle').innerText = deleteMode ? 'âœ‚ï¸ åˆ é™¤æ¨¡å¼ (å¼€å¯)' : 'âœ‚ï¸ åˆ é™¤æ¨¡å¼ (å…³é—­)';
            document.getElementById('delete-mode-toggle').classList.toggle('active', deleteMode);
        }

        function deletePoint(point) {
            let idx = points.indexOf(point);
            if (idx === -1) return;
            sticks = sticks.filter(s => s.p1 !== point && s.p2 !== point);
            points.splice(idx, 1);
        }

        function deleteStick(stick) {
            let idx = sticks.indexOf(stick);
            if (idx !== -1) sticks.splice(idx, 1);
        }

        // --- è‡ªåŠ¨è¿æ¥ä¸è§’åº¦çº¦æŸ ---
        function autoConnectIntersections() {
            if (isSimulating) { showToast("æµ‹è¯•ä¸­ä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½"); return; }
            if (sticks.length < 2) { showToast("è‡³å°‘éœ€è¦ä¸¤æ ¹æ†ä»¶"); return; }
            saveHistory();

            const EPS = 1e-4; const ENDPOINT_GUARD = 0.02; const MERGE_TOL = Math.max(2, CONFIG.snapDist * 0.25);
            const clusters = []; const splitMap = new Map();

            function pointLineDistance(px, py, ax, ay, bx, by) {
                const vx = bx - ax; const vy = by - ay;
                const len2 = vx * vx + vy * vy;
                if (len2 < EPS) return Math.hypot(px - ax, py - ay);
                const t = ((px - ax) * vx + (py - ay) * vy) / len2;
                const clamped = Math.max(0, Math.min(1, t));
                return Math.hypot(px - (ax + clamped * vx), py - (ay + clamped * vy));
            }

            function findNearbyNode(ix, iy, s1, s2) {
                let nearest = null, bestDist = CONFIG.snapDist;
                for (let p of points) {
                    const d = Math.hypot(p.x - ix, p.y - iy);
                    if (d >= bestDist) continue;
                    if (pointLineDistance(p.x, p.y, s1.p1.x, s1.p1.y, s1.p2.x, s1.p2.y) > MERGE_TOL) continue;
                    if (pointLineDistance(p.x, p.y, s2.p1.x, s2.p1.y, s2.p2.x, s2.p2.y) > MERGE_TOL) continue;
                    nearest = p; bestDist = d;
                }
                return nearest;
            }

            function findOrCreateCluster(x, y, existingNode) {
                for (let c of clusters) {
                    if (Math.hypot(c.x - x, c.y - y) <= MERGE_TOL) {
                        if (!c.existingNode && existingNode) c.existingNode = existingNode;
                        if (c.existingNode) { c.x = c.existingNode.x; c.y = c.existingNode.y; }
                        return c;
                    }
                }
                const cluster = { x: existingNode ? existingNode.x : x, y: existingNode ? existingNode.y : y, existingNode, node: null };
                clusters.push(cluster);
                return cluster;
            }

            function registerSplit(stick, t, cluster) {
                if (t <= ENDPOINT_GUARD || t >= 1 - ENDPOINT_GUARD) return;
                if (!splitMap.has(stick)) splitMap.set(stick, []);
                splitMap.get(stick).push({ t, cluster });
            }

            for (let i = 0; i < sticks.length; i++) {
                for (let j = i + 1; j < sticks.length; j++) {
                    const s1 = sticks[i], s2 = sticks[j];
                    if (s1.p1 === s2.p1 || s1.p1 === s2.p2 || s1.p2 === s2.p1 || s1.p2 === s2.p2) continue;
                    const denom = (s2.p2.y - s2.p1.y) * (s1.p2.x - s1.p1.x) - (s2.p2.x - s2.p1.x) * (s1.p2.y - s1.p1.y);
                    if (Math.abs(denom) < EPS) continue;
                    const ua = ((s2.p2.x - s2.p1.x) * (s1.p1.y - s2.p1.y) - (s2.p2.y - s2.p1.y) * (s1.p1.x - s2.p1.x)) / denom;
                    const ub = ((s1.p2.x - s1.p1.x) * (s1.p1.y - s2.p1.y) - (s1.p2.y - s1.p1.y) * (s1.p1.x - s2.p1.x)) / denom;
                    if (ua <= ENDPOINT_GUARD || ua >= 1 - ENDPOINT_GUARD || ub <= ENDPOINT_GUARD || ub >= 1 - ENDPOINT_GUARD) continue;
                    const ix = s1.p1.x + ua * (s1.p2.x - s1.p1.x);
                    const iy = s1.p1.y + ua * (s1.p2.y - s1.p1.y);
                    const nearbyNode = findNearbyNode(ix, iy, s1, s2);
                    const cluster = findOrCreateCluster(ix, iy, nearbyNode);
                    registerSplit(s1, ua, cluster);
                    registerSplit(s2, ub, cluster);
                }
            }

            let newNodesCount = 0, processedSticks = 0;
            for (let cluster of clusters) {
                cluster.node = cluster.existingNode || addPoint(cluster.x, cluster.y, false, currentMat);
                if (!cluster.existingNode) newNodesCount++;
            }

            for (let [stick, splits] of splitMap.entries()) {
                if (!splits.length) continue;
                const deduped = [];
                splits.sort((a, b) => a.t - b.t);
                for (let s of splits) {
                    const last = deduped[deduped.length - 1];
                    if (last && Math.abs(last.t - s.t) < ENDPOINT_GUARD) continue;
                    deduped.push(s);
                }
                if (!deduped.length) continue;
                const idx = sticks.indexOf(stick);
                if (idx === -1) continue;
                sticks.splice(idx, 1);
                let chain = [stick.p1, ...deduped.map(s => s.cluster.node), stick.p2];
                for (let i = 0; i < chain.length - 1; i++) {
                    const a = chain[i], b = chain[i + 1];
                    if (a === b || Math.hypot(a.x - b.x, a.y - b.y) < 0.5) continue;
                    sticks.push(new Stick(a, b, stick.mat.id));
                }
                processedSticks++;
            }

            if (newNodesCount > 0 || processedSticks > 0) showToast(`è¿æ¥å®Œæˆï¼š${processedSticks} æ†ä»¶ï¼Œ${newNodesCount} èŠ‚ç‚¹`);
            else showToast("æœªå‘ç°äº¤å‰ç‚¹");
        }

        function buildAngleConstraints() {
            angleConstraints = [];
            for (let node of points) {
                let neighbors = [];
                for (let s of sticks) {
                    let other = null;
                    if (s.p1 === node) other = s.p2;
                    else if (s.p2 === node) other = s.p1;
                    if (!other) continue;
                    let dx = other.x - node.x, dy = other.y - node.y;
                    let len = Math.hypot(dx, dy);
                    if (len < 0.01) continue;
                    neighbors.push({ point: other, initDirX: dx/len, initDirY: dy/len });
                }
                if (neighbors.length >= 2) angleConstraints.push({ node, neighbors });
            }
        }

        function applyAngleConstraints(iterations) {
            let stiffness = CONFIG.angleStiffness;
            for (let iter = 0; iter < iterations; iter++) {
                for (let c of angleConstraints) {
                    let node = c.node;
                    if (node.broken) continue;
                    for (let nb of c.neighbors) {
                        let p = nb.point;
                        if (p.broken) continue;
                        if (node.pinned && p.pinned) continue;
                        let dx = p.x - node.x, dy = p.y - node.y;
                        let dist = Math.hypot(dx, dy);
                        if (dist < 0.01) continue;
                        let targetX = node.x + nb.initDirX * dist;
                        let targetY = node.y + nb.initDirY * dist;
                        let moveX = (targetX - p.x) * stiffness;
                        let moveY = (targetY - p.y) * stiffness;
                        if (!node.pinned && !p.pinned) {
                            p.x += moveX; p.y += moveY; node.x -= moveX; node.y -= moveY;
                        } else if (!p.pinned) {
                            p.x += moveX; p.y += moveY;
                        } else if (!node.pinned) {
                            node.x -= moveX; node.y -= moveY;
                        }
                    }
                }
            }
        }

        function checkAngleBreaks() {
            for (let c of angleConstraints) {
                let node = c.node;
                if (node.broken) continue;
                let maxAngleDiff = 0;
                let neighbors = c.neighbors;
                let activeNeighbors = neighbors.filter(n => !n.point.broken && sticks.some(s => (s.p1===node && s.p2===n.point) || (s.p1===n.point && s.p2===node)));
                
                for (let i = 0; i < activeNeighbors.length; i++) {
                    for (let j = i+1; j < activeNeighbors.length; j++) {
                        let a = activeNeighbors[i], b = activeNeighbors[j];
                        let ax = a.point.x - node.x, ay = a.point.y - node.y;
                        let bx = b.point.x - node.x, by = b.point.y - node.y;
                        let curAngle = Math.atan2(ax*by - ay*bx, ax*bx + ay*by);
                        let initAngle = Math.atan2(a.initDirX*b.initDirY - a.initDirY*b.initDirX, a.initDirX*b.initDirX + a.initDirY*b.initDirY);
                        let diff = Math.abs(curAngle - initAngle);
                        if (diff > Math.PI) diff = 2*Math.PI - diff;
                        if (diff > maxAngleDiff) maxAngleDiff = diff;
                    }
                }
                if (maxAngleDiff > node.mat.angleStrength) {
                    node.broken = true; 
                }
            }
        }

        function getTopCluster() {
            const active = points.filter(p => !p.broken);
            if (!active.length) return null;
            const topY = active.reduce((m, p) => Math.min(m, p.y), active[0].y);
            const band = active.filter(p => p.y <= topY + 30);
            if (!band.length) return null;
            const centerX = band.reduce((sum, p) => sum + p.x, 0) / band.length;
            return { topY, centerX };
        }

        function drawLoadVisual() {
            if (!isSimulating || env.load <= 0) return;
            const top = getTopCluster();
            if (!top) return;
            const plateW = Math.max(120, Math.min(280, 110 + env.load * 1.4));
            const plateH = 16;
            const plateX = top.centerX - plateW / 2;
            const plateY = Math.max(30, top.topY - 26);
            const blockW = Math.max(90, plateW * 0.65);
            const blockH = 24 + env.load * 0.7;
            const blockX = top.centerX - blockW / 2;
            const blockY = plateY - blockH - 18;

            ctx.fillStyle = 'rgba(52, 73, 94, 0.95)'; ctx.fillRect(blockX, blockY, blockW, blockH);
            ctx.fillStyle = '#ecf0f1'; ctx.font = 'bold 14px Segoe UI'; ctx.textAlign = 'center';
            ctx.fillText(`${env.load}kg`, top.centerX, blockY + blockH / 2 + 5);
            ctx.strokeStyle = 'rgba(60, 60, 60, 0.9)'; ctx.lineWidth = 3; ctx.beginPath(); ctx.moveTo(top.centerX, blockY + blockH); ctx.lineTo(top.centerX, plateY); ctx.stroke();
            ctx.fillStyle = 'rgba(127, 140, 141, 0.95)'; ctx.fillRect(plateX, plateY, plateW, plateH); ctx.strokeRect(plateX, plateY, plateW, plateH);
        }

        function loop() {
            let iter = isSimulating ? 5 : 1;

            if (preheatRemaining > 0) {
                let steps = Math.min(5, preheatRemaining);
                for (let s = 0; s < steps; s++) {
                    for (let k = 0; k < iter; k++) {
                        if (isSimulating) refreshPointMasses();
                        points.forEach(p => p.update());
                        sticks.forEach(s => s.update());
                        if (isSimulating && angleConstraints.length > 0) applyAngleConstraints(1);
                    }
                    preheatRemaining--;
                }
            } else {
                for (let k = 0; k < iter; k++) {
                    if (isSimulating) refreshPointMasses();
                    points.forEach(p => p.update());
                    sticks.forEach(s => s.update());
                    if (isSimulating && angleConstraints.length > 0) applyAngleConstraints(1);
                }
                if (isSimulating && angleConstraints.length > 0) {
                    applyAngleConstraints(CONFIG.angleIterations);
                    checkAngleBreaks();
                }
            }

            // === ç‰©ç†å¼•æ“æ ¸å¿ƒä¿®æ”¹ï¼šæ–­è£‚æ¸…ç†ä¸è‡ªç”±è½ä½“ ===
            if (isSimulating) {
                let somethingBroke = false;

                // 1. è®°å½•å¹¶ç”Ÿæˆæ†ä»¶æ–­è£‚ç‰¹æ•ˆ
                sticks.forEach(s => {
                    if (s.broken) {
                        // ä»…è®°å½•å› åº”åŠ›æ–­è£‚çš„ï¼Œä¸è®°å½•è¢«åŠ¨åˆ é™¤çš„
                        if(!breakLog.find(l => l.type === 'stick' && l.simId === s.simId)) {
                             breakLog.push({ type: 'stick', simId: s.simId, order: nextBreakOrder++ });
                             createExplosion((s.p1.x + s.p2.x)/2, (s.p1.y + s.p2.y)/2, s.mat.color);
                             somethingBroke = true;
                        }
                    }
                });

                // 2. è®°å½•å¹¶ç”ŸæˆèŠ‚ç‚¹æ–­è£‚ç‰¹æ•ˆ
                points.forEach(p => {
                    if (p.broken) {
                        if(!breakLog.find(l => l.type === 'point' && l.simId === p.simId)) {
                            breakLog.push({ type: 'point', simId: p.simId, order: nextBreakOrder++ });
                            createExplosion(p.x, p.y, p.mat.color);
                            somethingBroke = true;
                        }
                    }
                });

                // 3. æ‰§è¡Œåˆ é™¤ï¼ˆè¿‡æ»¤åˆ—è¡¨ï¼‰
                // å…ˆè¿‡æ»¤æ‰å·²ç»æ˜ç¡®æ–­æ‰çš„æ†
                let activeSticks = sticks.filter(s => !s.broken);
                
                // å†è¿‡æ»¤æ‰å·²ç»æ˜ç¡®æ–­æ‰çš„ç‚¹
                let activePoints = points.filter(p => !p.broken);

                // 4. æ ¸å¿ƒé€»è¾‘ï¼šå­¤ç«‹èŠ‚ç‚¹æ£€æµ‹ï¼ˆä¸¤ä¾§æ†éƒ½æ–­è£‚çš„æƒ…å†µï¼‰
                // éå†æ‰€æœ‰å­˜æ´»çš„èŠ‚ç‚¹ï¼Œæ£€æŸ¥å®ƒè¿˜æœ‰å¤šå°‘æ ¹æ†è¿ç€
                let pointsToDelete = [];
                activePoints.forEach(p => {
                    if (p.pinned) return; // åœ°åŸºæ°¸è¿œä¸åˆ 
                    let connectedCount = activeSticks.filter(s => s.p1 === p || s.p2 === p).length;
                    if (connectedCount === 0) {
                        pointsToDelete.push(p);
                        createExplosion(p.x, p.y, p.mat.color);
                        // è¿™ç§æƒ…å†µå±äºè¢«åŠ¨æ¸…ç†ï¼Œé€šå¸¸ä¸ç®—ä½œç»“æ„æ€§ç ´åçš„"First Break"ï¼Œä½†ä¸ºäº†è§†è§‰è¿è´¯ï¼Œä¹Ÿå¯ä»¥ä¸è®°å½•è¿›Logï¼Œæˆ–è€…è®°å½•
                        // è¿™é‡Œé€‰æ‹©ä¸è®°å½•è¿› breakLog (å› ä¸ºå®ƒä¸æ˜¯å—åŠ›ç ´åï¼Œè€Œæ˜¯å˜æˆäº†åƒåœ¾)ï¼Œé˜²æ­¢æŠ¢å â€œå‰ä¸‰ä¸ªæ–­è£‚â€çš„åé¢
                    }
                });

                // ä»activePointsä¸­ç§»é™¤å­¤ç«‹èŠ‚ç‚¹
                if (pointsToDelete.length > 0) {
                    activePoints = activePoints.filter(p => !pointsToDelete.includes(p));
                }

                // 5. åå‘æ¸…ç†ï¼šå¦‚æœæœ‰èŠ‚ç‚¹è¢«åˆ é™¤äº†ï¼ˆæ— è®ºæ˜¯å—åŠ›æ–­è£‚è¿˜æ˜¯å­¤ç«‹åˆ é™¤ï¼‰ï¼Œè¿åœ¨å®ƒä¸Šé¢çš„æ†ä¹Ÿå¿…é¡»åˆ 
                activeSticks = activeSticks.filter(s => activePoints.includes(s.p1) && activePoints.includes(s.p2));

                // 6. æ›´æ–°å…¨å±€åˆ—è¡¨
                points = activePoints;
                sticks = activeSticks;
            }

            // æ›´æ–°ç¢ç‰‡
            fragments.forEach(f => f.update());
            fragments = fragments.filter(f => f.life > 0);

            ctx.clearRect(0, 0, width, height);
            drawGrid();

            ctx.fillStyle = "#95a5a6";
            ctx.fillRect(0, groundY, width, CONFIG.groundHeight);

            drawLoadVisual();
            sticks.forEach(s => s.draw());
            
            points.forEach(p => {
                if (isSimulating && p.broken) return;

                // å¤ç›˜é«˜äº®ç»˜åˆ¶
                if (!isSimulating && p.wasBroken && p.breakOrder > 0 && p.breakOrder <= 3) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
                    ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3; ctx.stroke();
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                    ctx.fillStyle = p.mat.color; ctx.fill();
                    return;
                }

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.pinned ? 8 : 5, 0, Math.PI*2);
                ctx.fillStyle = p.pinned ? "#34495e" : p.mat.color;
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.5)"; ctx.lineWidth = 1; ctx.stroke();
            });

            fragments.forEach(f => f.draw(ctx));

            if (deleteMode && !isSimulating) {
                hoveredStick = null;
                let stickDist = 10;
                for (let s of sticks) {
                    let d = distanceToSegment(mouse, s.p1, s.p2);
                    if (d < stickDist) { stickDist = d; hoveredStick = s; }
                }
                if (hoveredStick) {
                    ctx.beginPath();
                    ctx.moveTo(hoveredStick.p1.x, hoveredStick.p1.y);
                    ctx.lineTo(hoveredStick.p2.x, hoveredStick.p2.y);
                    ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 8; ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
                }
            }

            if (!isSimulating) drawInteraction();
            updateStats();
            requestAnimationFrame(loop);
        }

        function distanceToSegment(p, a, b) {
            let abx = b.x - a.x, aby = b.y - a.y;
            let apx = p.x - a.x, apy = p.y - a.y;
            let ab2 = abx*abx + aby*aby;
            if (ab2 === 0) return Math.hypot(p.x - a.x, p.y - a.y);
            let t = (apx*abx + apy*aby) / ab2;
            t = Math.max(0, Math.min(1, t));
            return Math.hypot(p.x - (a.x + abx * t), p.y - (a.y + aby * t));
        }

        function drawGrid() {
            ctx.strokeStyle = "rgba(0,0,0,0.06)";
            ctx.lineWidth = 1;
            for(let x=0; x<width; x+=40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke(); }
            for(let y=height; y>0; y-=40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke(); }
        }

        function drawInteraction() {
            hoveredPoint = null;
            let minDist = CONFIG.snapDist;
            for (let p of points) {
                let d = Math.hypot(p.x - mouse.x, p.y - mouse.y);
                if (d < minDist) { minDist = d; hoveredPoint = p; }
            }

            if (deleteMode) {
                canvas.style.cursor = "cell";
                if (hoveredPoint) {
                    ctx.beginPath(); ctx.arc(hoveredPoint.x, hoveredPoint.y, 12, 0, Math.PI*2);
                    ctx.strokeStyle = "#e74c3c"; ctx.lineWidth = 3; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
            } else {
                if (hoveredPoint) {
                    ctx.beginPath(); ctx.arc(hoveredPoint.x, hoveredPoint.y, 12, 0, Math.PI*2);
                    ctx.strokeStyle = MATERIALS[currentMat].color; 
                    ctx.lineWidth = 2; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                    canvas.style.cursor = "pointer";
                } else if (mouse.y >= groundY - 10) {
                    canvas.style.cursor = "cell";
                } else {
                    canvas.style.cursor = "default";
                }
            }

            if (isDragging && dragStart && !deleteMode) {
                let targetX = hoveredPoint ? hoveredPoint.x : mouse.x;
                let targetY = hoveredPoint ? hoveredPoint.y : mouse.y;
                let dx = targetX - dragStart.x, dy = targetY - dragStart.y;
                let dist = Math.hypot(dx, dy);
                let segments = Math.ceil(dist / CONFIG.maxStickLen);

                ctx.beginPath(); ctx.moveTo(dragStart.x, dragStart.y); ctx.lineTo(targetX, targetY);
                ctx.strokeStyle = MATERIALS[currentMat].color; ctx.lineWidth = 3; ctx.setLineDash([5, 5]); ctx.stroke(); ctx.setLineDash([]);
                if (segments > 1) {
                    ctx.fillStyle = "#e67e22"; ctx.font = "12px Arial";
                    ctx.fillText(`${segments}æ®µè¿æ¥`, mouse.x + 10, mouse.y);
                }
            }
        }

        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left; mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', e => {
            if (isSimulating) { showToast("âš ï¸ æµ‹è¯•ä¸­æ— æ³•ä¿®æ”¹ï¼Œè¯·å…ˆåœæ­¢ï¼"); return; }
            if (e.button === 2) return;
            if (deleteMode) {
                if (hoveredPoint) { saveHistory(); deletePoint(hoveredPoint); showToast("åˆ é™¤èŠ‚ç‚¹"); }
                else if (hoveredStick) { saveHistory(); deleteStick(hoveredStick); showToast("åˆ é™¤æ†ä»¶"); }
                return;
            }
            if (hoveredPoint) { dragStart = hoveredPoint; isDragging = true; }
            else if (mouse.y > groundY - 15) { let p = addPoint(mouse.x, groundY, true, currentMat); dragStart = p; isDragging = true; }
        });

        canvas.addEventListener('mouseup', e => {
            if (isSimulating || deleteMode) return;
            if (!isDragging || !dragStart) return;
            let endP = hoveredPoint;
            let finalX = endP ? endP.x : mouse.x;
            let finalY = endP ? endP.y : mouse.y;
            if (!endP && finalY > groundY) finalY = groundY;
            let dx = finalX - dragStart.x, dy = finalY - dragStart.y;
            let dist = Math.hypot(dx, dy);

            if (dist > 5) {
                saveHistory();
                let segments = Math.ceil(dist / CONFIG.maxStickLen);
                let currentStart = dragStart;
                for (let i = 1; i <= segments; i++) {
                    let isLast = (i === segments);
                    let nextP;
                    if (isLast && endP) { nextP = endP; }
                    else {
                        let ratio = i / segments;
                        let nx = dragStart.x + dx * ratio;
                        let ny = dragStart.y + dy * ratio;
                        let pin = (isLast && ny >= groundY - 1);
                        if (pin) ny = groundY;
                        nextP = addPoint(nx, ny, pin, currentMat);
                    }
                    if (currentStart !== nextP) {
                        let exists = sticks.some(s => (s.p1 === currentStart && s.p2 === nextP) || (s.p1 === nextP && s.p2 === currentStart));
                        if (!exists) sticks.push(new Stick(currentStart, nextP, currentMat));
                    }
                    currentStart = nextP;
                }
            }
            isDragging = false; dragStart = null;
        });

        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (isSimulating) return;
            if (!deleteMode && hoveredPoint) { saveHistory(); deletePoint(hoveredPoint); showToast("åˆ é™¤èŠ‚ç‚¹"); }
        });

        function saveBlueprint() {
            let savedPoints = points.map(p => ({ x: p.x, y: p.y, pinned: p.pinned, matId: p.mat.id, uid: p.simId }));
            let savedSticks = sticks.map(s => ({ p1_idx: points.indexOf(s.p1), p2_idx: points.indexOf(s.p2), matId: s.mat.id, uid: s.simId }));
            blueprint = { points: savedPoints, sticks: savedSticks };
        }

        function restoreBlueprint() {
            if (!blueprint) return;
            fragments = [];
            points = []; sticks = [];
            // é‡å»ºè“å›¾
            blueprint.points.forEach(bp => addPoint(bp.x, bp.y, bp.pinned, bp.matId, bp.uid));
            blueprint.sticks.forEach(bs => {
                if (points[bs.p1_idx] && points[bs.p2_idx]) sticks.push(new Stick(points[bs.p1_idx], points[bs.p2_idx], bs.matId, bs.uid));
            });

            // å°† breakLog åº”ç”¨å›é‡å»ºçš„å¯¹è±¡ä¸Šï¼Œç”¨äºé«˜äº®æ˜¾ç¤º
            breakLog.forEach(log => {
                if (log.type === 'stick') {
                    let s = sticks.find(item => item.simId === log.simId);
                    if (s) { s.wasBroken = true; s.breakOrder = log.order; }
                } else if (log.type === 'point') {
                    let p = points.find(item => item.simId === log.simId);
                    if (p) { p.wasBroken = true; p.breakOrder = log.order; }
                }
            });
        }

        window.setMaterial = (matId) => {
            currentMat = matId;
            document.querySelectorAll('.mat-option').forEach(el => el.classList.remove('active'));
            document.getElementById('mat-' + matId).classList.add('active');
            showToast(`å·²åˆ‡æ¢ææ–™ä¸ºï¼š${MATERIALS[matId].name}`);
        };

        window.updateEnv = (type, val) => {
            env[type] = parseInt(val);
            let text = val;
            if (type === 'wind' || type === 'quake') text += "çº§";
            if (type === 'load') text += "kg";
            document.getElementById(`val-${type}`).innerText = text;
        };

        window.toggleSimulation = () => {
            const btn = document.getElementById('btn-mode');
            const sliders = document.querySelectorAll('input[type=range]');

            if (!isSimulating) {
                statsLocked = true;
                saveBlueprint();
                // æ¸…ç†çŠ¶æ€
                breakLog = [];
                nextBreakOrder = 1;
                fragments = [];
                points.forEach(p => { p.broken = false; });
                sticks.forEach(s => { s.broken = false; });
                
                angleConstraints = [];
                buildAngleConstraints();
                isSimulating = true;
                preheatRemaining = 40;
                btn.innerHTML = "â¹ï¸ åœæ­¢æµ‹è¯•";
                btn.classList.add('testing');
                sliders.forEach(s => s.disabled = false);
                showToast("æµ‹è¯•å¼€å§‹ï¼šé‡åŠ›å¼•æ“å·²å…¨å¼€");
            } else {
                statsLocked = false;
                restoreBlueprint();
                isSimulating = false;
                preheatRemaining = 0;
                angleConstraints = [];
                btn.innerHTML = "â–¶ï¸ å¼€å§‹æµ‹è¯•";
                btn.classList.remove('testing');
                sliders.forEach(s => { s.value = 0; s.disabled = true; });
                env = { wind: 0, quake: 0, load: 0 };
                document.getElementById('val-wind').innerText = "0çº§";
                document.getElementById('val-quake').innerText = "0çº§";
                document.getElementById('val-load').innerText = "0kg";
                showToast("å¤ç›˜æ¨¡å¼ï¼šçº¢è‰²æ ‡è®°ä¸ºæœ€å…ˆæ–­è£‚å¤„");
            }
        };

        window.clearAll = () => {
            if (isSimulating) return;
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰è®¾è®¡å—ï¼Ÿ")) {
                points = []; sticks = []; fragments = []; breakLog = [];
                init(); blueprint = null;
                saveHistory();
                showToast("å·²æ¸…ç©º");
            }
        };

        window.undo = () => undo();
        window.toggleDeleteMode = () => toggleDeleteMode();
        window.autoConnectIntersections = () => autoConnectIntersections();

        function showToast(msg) {
            let t = document.getElementById('toast');
            if (t) { t.innerText = msg; t.style.opacity = 1; setTimeout(() => t.style.opacity = 0, 2000); }
        }

        function updateStats() {
            const getEl = (id) => document.getElementById(id);
            
            let maxH = 0;
            points.forEach(p => { if (!p.broken) maxH = Math.max(maxH, groundY - p.y); });
            let heightText = Math.round(maxH / CONFIG.scale) + " cm";
            let elMainHeight = document.getElementById('height-indicator');
            if (elMainHeight) elMainHeight.innerText = `ğŸ”ï¸ æœ€é«˜ç‚¹ï¼š${heightText}`;

            if (statsLocked) return;

            let nodeCount = points.length;
            let elNodes = getEl('stat-nodes');
            if (elNodes) elNodes.innerText = nodeCount;

            let lenWood = 0, lenSteel = 0, lenCarbon = 0;
            sticks.forEach(s => {
                let l = s.len / CONFIG.scale;
                if (s.mat.id === 'wood') lenWood += l;
                else if (s.mat.id === 'steel') lenSteel += l;
                else if (s.mat.id === 'carbon') lenCarbon += l;
            });

            let elLenWood = getEl('stat-len-wood'); if (elLenWood) elLenWood.innerText = Math.round(lenWood);
            let elLenSteel = getEl('stat-len-steel'); if (elLenSteel) elLenSteel.innerText = Math.round(lenSteel);
            let elLenCarbon = getEl('stat-len-carbon'); if (elLenCarbon) elLenCarbon.innerText = Math.round(lenCarbon);

            let totalLength = lenWood + lenSteel + lenCarbon;
            let elTotalLen = getEl('stat-total-length'); if (elTotalLen) elTotalLen.innerText = Math.round(totalLength);

            let cost = nodeCount * CONFIG.nodeBaseCost + lenWood*2 + lenSteel*8 + lenCarbon*20;
            let elCost = getEl('stat-cost'); if (elCost) elCost.innerText = Math.round(cost);
        }

        init();
    })();
</script>
</body>
</html>
