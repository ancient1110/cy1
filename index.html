<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>å¡”å°å·¥ç¨‹æ¨¡æ‹Ÿå™¨ï¼ˆé‡æ„ç‰ˆï¼‰</title>
  <style>
    :root { color-scheme: light; }
    body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; margin: 0; overflow: hidden; background: #f0f2f5; display: flex; user-select: none; }
    #canvas-container { flex-grow: 1; height: 100vh; position: relative; background: radial-gradient(circle at center, #fff 0%, #eef2f3 100%); cursor: crosshair; }
    #sidebar { width: 310px; height: 100vh; background: #fff; border-left: 1px solid #ddd; display: flex; flex-direction: column; box-shadow: -4px 0 12px rgba(0,0,0,0.06); z-index: 100; flex-shrink: 0; }
    .sidebar-scroll { padding: 12px 14px; overflow-y: auto; flex-grow: 1; }
    h2 { font-size: 13px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 4px; margin: 14px 0 8px; }
    h2:first-child { margin-top: 0; }
    .mode-btn { width: 100%; padding: 11px; border: none; border-radius: 8px; font-size: 15px; font-weight: bold; cursor: pointer; color: #fff; background: linear-gradient(135deg, #2ecc71, #27ae60); box-shadow: 0 4px 10px rgba(46,204,113,0.35); margin-bottom: 10px; transition: all .2s; }
    .mode-btn.running { background: linear-gradient(135deg, #e74c3c, #c0392b); box-shadow: 0 4px 10px rgba(231,76,60,0.35); }
    .mode-btn:active { transform: scale(0.98); }
    .mat-row { display: flex; gap: 6px; margin-bottom: 8px; }
    .mat-card { flex: 1; padding: 7px 3px; border: 2px solid #eee; border-radius: 6px; text-align: center; cursor: pointer; font-size: 11px; background: #fafafa; transition: .15s; }
    .mat-card:hover { border-color: #bbb; }
    .mat-card.active { border-color: #3498db; background: #ebf5fb; color: #2980b9; font-weight: bold; }
    .slider-box { background: #f8f9fa; border-radius: 6px; padding: 6px 8px; margin-bottom: 6px; }
    .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: #555; margin-bottom: 3px; }
    input[type=range] { width: 100%; cursor: pointer; accent-color: #3498db; }
    .stat-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; color: #555; }
    .total-cost { display: flex; justify-content: space-between; align-items: baseline; font-size: 20px; color: #e67e22; font-weight: bold; margin-top: 8px; }
    .btn-row { display: flex; gap: 6px; margin-top: 8px; }
    .btn-s { flex: 1; background: #ecf0f1; border: none; padding: 7px 0; border-radius: 4px; cursor: pointer; font-size: 12px; color: #555; }
    .btn-s:hover { background: #ffeaa7; color: #d35400; }
    .btn-s.danger { background: #fde6e6; color: #c0392b; }
    .btn-s.danger:hover { background: #f5b7b1; }
    #btn-del { width: 100%; margin-top: 6px; padding: 7px; background: #ecf0f1; border: 2px solid #bdc3c7; border-radius: 4px; cursor: pointer; font-size: 12px; }
    #btn-del.active { background: #e74c3c; border-color: #c0392b; color: #fff; }
    .btn-special { width: 100%; margin-top: 8px; padding: 8px; background: #3498db; color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 13px; }
    .btn-special:hover { background: #2980b9; }
    #toast { position: absolute; top: 18px; left: 50%; transform: translateX(-50%); background: rgba(44,62,80,.88); color: #fff; padding: 8px 18px; border-radius: 30px; opacity: 0; transition: opacity .4s; pointer-events: none; font-size:13px; }
    #height-indicator { position: absolute; top: 12px; left: 14px; background: rgba(255,255,255,.92); color: #2c3e50; border: 1px solid #d5d8dc; border-radius: 10px; padding: 7px 12px; font-size: 13px; font-weight: 600; pointer-events: none; box-shadow: 0 3px 8px rgba(0,0,0,.08); }
    #replay-banner { position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%); background: rgba(231,76,60,.9); color: #fff; padding: 8px 18px; border-radius: 20px; font-size: 13px; display: none; }
  </style>
</head>
<body>
  <div id="canvas-container">
    <canvas id="simCanvas"></canvas>
    <div id="toast"></div>
    <div id="height-indicator">ğŸ”ï¸ æœ€é«˜ç‚¹ï¼š0 cm</div>
    <div id="replay-banner">ğŸ” å¤ç›˜æ¨¡å¼ï¼šçº¢è‰²æ ‡è®°ä¸ºæœ€å…ˆæ–­è£‚å¤„</div>
  </div>

  <div id="sidebar">
    <div class="sidebar-scroll">
      <button id="btn-mode" class="mode-btn" onclick="toggleSim()">â–¶ï¸ å¼€å§‹æµ‹è¯•</button>
      <h2>ğŸ—ï¸ ææ–™é€‰æ‹©</h2>
      <div class="mat-row">
        <div class="mat-card active" onclick="setMat(0)" id="mat-0"><div style="width:10px;height:10px;background:#8e44ad;border-radius:50%;margin:0 auto 4px"></div>æœ¨æ¡<br>Â¥2/cm</div>
        <div class="mat-card" onclick="setMat(1)" id="mat-1"><div style="width:10px;height:10px;background:#2c3e50;border-radius:50%;margin:0 auto 4px"></div>é’¢ç®¡<br>Â¥8/cm</div>
        <div class="mat-card" onclick="setMat(2)" id="mat-2"><div style="width:10px;height:10px;background:#2980b9;border-radius:50%;margin:0 auto 4px"></div>ç¢³çº¤<br>Â¥20/cm</div>
      </div>
      <h2>ğŸ›ï¸ ç¯å¢ƒè½½è·</h2>
      <div class="slider-box"><div class="slider-label"><span>ğŸ’¨ é£åŠ›</span><span id="disp-wind">0çº§</span></div><input type="range" id="range-wind" min="0" max="100" value="0" disabled oninput="setEnv('wind',this.value)"></div>
      <div class="slider-box"><div class="slider-label"><span>ğŸŒ‹ åœ°éœ‡</span><span id="disp-quake">0çº§</span></div><input type="range" id="range-quake" min="0" max="100" value="0" disabled oninput="setEnv('quake',this.value)"></div>
      <div class="slider-box"><div class="slider-label"><span>âš–ï¸ é¡¶éƒ¨å‹é‡</span><span id="disp-load">0kg</span></div><input type="range" id="range-load" min="0" max="100" value="0" disabled oninput="setEnv('load',this.value)"></div>

      <h2>ğŸ“Š å·¥ç¨‹é€ ä»·å•</h2>
      <div class="stat-row"><span>èŠ‚ç‚¹æ•°:</span><span id="count-node">0</span> Ã— Â¥50</div>
      <div class="stat-row"><span>æ†ä»¶æ€»é•¿:</span><span id="stat-total-len">0 cm</span></div>
      <div class="stat-row"><span>æœ¨æ¡:</span><span id="stat-len-wood">0 cm</span> (Â¥2)</div>
      <div class="stat-row"><span>é’¢ç®¡:</span><span id="stat-len-steel">0 cm</span> (Â¥8)</div>
      <div class="stat-row"><span>ç¢³çº¤:</span><span id="stat-len-carbon">0 cm</span> (Â¥20)</div>
      <div class="stat-row"><span>æœ€å¤§åº”åŠ›:</span><span id="max-stress">0%</span></div>
      <div class="total-cost"><span>æ€»ä»·:</span><span>Â¥<span id="cost-total">0</span></span></div>

      <div class="btn-row"><button class="btn-s" onclick="undo()">â†©ï¸ æ’¤é”€</button><button class="btn-s danger" onclick="clearAll()">ğŸ—‘ï¸ æ¸…ç©º</button></div>
      <button id="btn-del" onclick="toggleDel()">âœ‚ï¸ åˆ é™¤æ¨¡å¼ï¼šå…³é—­</button>
      <button class="btn-special" onclick="autoConnect()">ğŸ”— è‡ªåŠ¨è¿æ¥äº¤å‰ç‚¹</button>
    </div>
  </div>

<script>
const PHYSICS = {
  pxPerMeter: 45,
  gravity: 9.81,
  dt: 1 / 60,
  damping: 0.985,
  windRef: 20,
  solverSubSteps: 8,
  forceCapFactor: 1.35,
  maxNodeSpeed: 8,
  overloadFramesToFail: 18,
  startupRampFrames: 150,
  breakGraceFrames: 150,
  nodeLumpedMass: 0.9
};
const MATERIALS = [
  { name: 'æœ¨æ¡', color: '#8e44ad', cost: 2, E: 9e9, density: 500, area: 0.0009, tensile: 35e6, compressive: 24e6, radius: 0.012 },
  { name: 'é’¢ç®¡', color: '#2c3e50', cost: 8, E: 200e9, density: 7800, area: 0.0012, tensile: 280e6, compressive: 250e6, radius: 0.02 },
  { name: 'ç¢³çº¤', color: '#2980b9', cost: 20, E: 140e9, density: 1600, area: 0.0006, tensile: 600e6, compressive: 250e6, radius: 0.01 }
];

const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

let nextId = 1;
class Node {
  constructor(x, y, pinned = false, matIdx = 0) { this.id = nextId++; this.x = x; this.y = y; this.vx = 0; this.vy = 0; this.fx = 0; this.fy = 0; this.mass = 5; this.pinned = pinned; this.matIdx = matIdx; this.broken = false; this.wasBroken = false; this.breakOrder = 0; this.baseX = x; }
}
class Member {
  constructor(a, b, matIdx) {
    this.id = nextId++; this.a = a; this.b = b; this.matIdx = matIdx; this.mat = MATERIALS[matIdx];
    this.l0 = this.lengthPx(); this.forceN = 0; this.ratio = 0; this.overloadCount = 0; this.broken = false; this.wasBroken = false; this.breakOrder = 0;
  }
  lengthPx() { return Math.hypot(this.a.x - this.b.x, this.a.y - this.b.y); }
  lengthM() { return this.lengthPx() / PHYSICS.pxPerMeter; }
}

const state = {
  nodes: [], members: [], matIdx: 0, simulating: false, deleting: false,
  env: { wind: 0, quake: 0, load: 0 }, history: [], dragStart: null, dragging: false,
  hoverNode: null, hoverMember: null, mouse: { x: 0, y: 0 }, fragments: [],
  blueprint: null, breakLog: [], nextBreakOrder: 1, simFrames: 0
};

function resize() {
  canvas.width = document.getElementById('canvas-container').offsetWidth;
  canvas.height = document.getElementById('canvas-container').offsetHeight;
}

function addNode(x, y, pinned = false, matIdx = state.matIdx) { const n = new Node(x, y, pinned, matIdx); state.nodes.push(n); return n; }
function addMember(a, b, matIdx = state.matIdx) { if (a === b) return null; if (state.members.some(m => (m.a === a && m.b === b) || (m.a === b && m.b === a))) return null; const m = new Member(a, b, matIdx); state.members.push(m); return m; }

function initScene() {
  state.nodes = []; state.members = []; state.history = []; state.breakLog = []; state.nextBreakOrder = 1; state.fragments = [];
  const y = canvas.height - 60;
  addNode(canvas.width / 2 - 70, y, true);
  addNode(canvas.width / 2 + 70, y, true);
  saveHistory();
}

function serialize() {
  return {
    nextId,
    nodes: state.nodes.map(n => ({ ...n })),
    members: state.members.map(m => ({ id: m.id, a: m.a.id, b: m.b.id, matIdx: m.matIdx, l0: m.l0 }))
  };
}
function restore(snapshot) {
  nextId = snapshot.nextId;
  const map = new Map();
  state.nodes = snapshot.nodes.map(n => { const nn = new Node(n.x, n.y, n.pinned, n.matIdx); Object.assign(nn, n); map.set(nn.id, nn); return nn; });
  state.members = snapshot.members.map(m => { const mm = new Member(map.get(m.a), map.get(m.b), m.matIdx); mm.id = m.id; mm.l0 = m.l0; return mm; });
}
function saveHistory() { if (state.simulating) return; if (state.history.length >= 40) state.history.shift(); state.history.push(serialize()); }
window.undo = () => { if (state.simulating) return toast('æµ‹è¯•ä¸­ä¸èƒ½æ’¤é”€'); if (state.history.length <= 1) return toast('æ²¡æœ‰æ›´å¤šæ­¥éª¤'); state.history.pop(); restore(state.history[state.history.length - 1]); toast('æ’¤é”€æˆåŠŸ'); };

window.setMat = idx => { state.matIdx = idx; document.querySelectorAll('.mat-card').forEach((el, i) => el.className = i === idx ? 'mat-card active' : 'mat-card'); };
window.setEnv = (key, value) => { state.env[key] = Number(value); document.getElementById(`disp-${key}`).innerText = `${value}${key === 'load' ? 'kg' : 'çº§'}`; };
window.toggleDel = () => { state.deleting = !state.deleting; const btn = document.getElementById('btn-del'); btn.className = state.deleting ? 'active' : ''; btn.textContent = `âœ‚ï¸ åˆ é™¤æ¨¡å¼ï¼š${state.deleting ? 'å¼€å¯' : 'å…³é—­'}`; };

window.clearAll = () => {
  if (state.simulating) return;
  if (!confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰è®¾è®¡ï¼Ÿ')) return;
  initScene();
  document.getElementById('replay-banner').style.display = 'none';
  toast('å·²æ¸…ç©º');
};

function makeFragments(x, y, color) { for (let i = 0; i < 10; i++) state.fragments.push({ x, y, vx: (Math.random() - 0.5) * 4, vy: Math.random() * -3, life: 1, color }); }
function drawFragments() { state.fragments.forEach(f => { f.x += f.vx; f.y += f.vy; f.vy += 0.18; f.life -= 0.02; ctx.globalAlpha = Math.max(0, f.life); ctx.fillStyle = f.color; ctx.fillRect(f.x, f.y, 3, 3); }); ctx.globalAlpha = 1; state.fragments = state.fragments.filter(f => f.life > 0); }

function evaluateStructure() {
  state.simFrames += 1;
  const startupRamp = Math.min(1, state.simFrames / PHYSICS.startupRampFrames);
  const canBreak = state.simFrames > PHYSICS.breakGraceFrames;

  state.nodes.forEach(n => { n.fx = 0; n.fy = 0; n.mass = PHYSICS.nodeLumpedMass; });
  const activeMembers = state.members.filter(m => !m.broken && !m.a.broken && !m.b.broken);

  for (const m of activeMembers) {
    const L = Math.max(0.1, m.lengthM());
    const mass = m.mat.density * m.mat.area * L;
    m.a.mass += mass * 0.5;
    m.b.mass += mass * 0.5;
  }

  const liveNodes = state.nodes.filter(n => !n.pinned && !n.broken);
  liveNodes.forEach(n => n.fy += n.mass * PHYSICS.gravity * startupRamp);

  if (state.env.load > 0 && liveNodes.length) {
    const topY = Math.min(...liveNodes.map(n => n.y));
    const topNodes = liveNodes.filter(n => n.y <= topY + 20);
    const F = (state.env.load * PHYSICS.gravity * startupRamp) / Math.max(1, topNodes.length);
    topNodes.forEach(n => n.fy += F);
  }

  if (state.env.wind > 0 && liveNodes.length) {
    const topY = Math.min(...liveNodes.map(n => n.y));
    const Hm = Math.max(1, (canvas.height - 60 - topY) / PHYSICS.pxPerMeter);
    const q = 0.613 * Math.pow((state.env.wind / 100) * PHYSICS.windRef, 2);
    const sway = Math.sin(performance.now() / 700);
    const sumWeight = liveNodes.reduce((acc, n) => acc + Math.max(1, (canvas.height - 60 - n.y)), 0);
    liveNodes.forEach(n => {
      const share = Math.max(1, (canvas.height - 60 - n.y)) / sumWeight;
      n.fx += sway * q * Hm * 0.3 * share * startupRamp;
    });
  }

  if (state.env.quake > 0) {
    const ag = (state.env.quake / 100) * 0.8 * PHYSICS.gravity;
    const ax = Math.sin(performance.now() / 160) * ag;
    liveNodes.forEach(n => n.fx += n.mass * ax * startupRamp);
    state.nodes.filter(n => n.pinned).forEach(n => {
      n.x = n.baseX + Math.sin(performance.now() / 160) * (state.env.quake / 100) * 6;
    });
  } else {
    state.nodes.filter(n => n.pinned).forEach(n => n.x = n.baseX);
  }

  // æ ¸å¿ƒæŠ˜ä¸­ï¼šä¿ç•™å·¥ç¨‹åŒ–è®¡ç®—ï¼ŒåŒæ—¶å¢åŠ æ•°å€¼é™å¹…ä¸å»¶è¿Ÿç ´åï¼Œå¢å¼ºæŠ—è„†å¼±æ€§
  const dt = PHYSICS.dt / PHYSICS.solverSubSteps;
  for (let k = 0; k < PHYSICS.solverSubSteps; k++) {
    for (const m of activeMembers) {
      const dx = m.b.x - m.a.x;
      const dy = m.b.y - m.a.y;
      const Lpx = Math.hypot(dx, dy) || 1;
      const Lm = Lpx / PHYSICS.pxPerMeter;
      const ux = dx / Lpx;
      const uy = dy / Lpx;
      const strain = (Lpx - m.l0) / Math.max(1, m.l0);
      const kAxial = (m.mat.E * m.mat.area) / Math.max(0.08, Lm);

      // é™å¹…é¿å…â€œç§‘å­¦å‚æ•° + å¤§æ­¥é•¿â€é€ æˆç¬æ€çˆ†ç‚¸
      const materialLimit = m.mat.tensile * m.mat.area;
      const forceCap = materialLimit * PHYSICS.forceCapFactor;
      const force = Math.max(-forceCap, Math.min(forceCap, kAxial * strain));

      m.forceN = force;
      const compLimit = bucklingLimit(m, Lm) * m.mat.area;
      m.ratio = force >= 0 ? force / materialLimit : Math.abs(force) / Math.max(1, compLimit);
      m.a.fx += force * ux;
      m.a.fy += force * uy;
      m.b.fx -= force * ux;
      m.b.fy -= force * uy;
    }

    for (const n of liveNodes) {
      const ax = n.fx / n.mass;
      const ay = n.fy / n.mass;
      n.vx = (n.vx + ax * dt) * PHYSICS.damping;
      n.vy = (n.vy + ay * dt) * PHYSICS.damping;

      // èŠ‚ç‚¹é€Ÿåº¦é™å¹…ï¼Œé¿å…ä¸ªåˆ«æ†ä»¶æ–­è£‚è§¦å‘è¿é”æ•°å€¼é£æ•£
      const v = Math.hypot(n.vx, n.vy);
      if (v > PHYSICS.maxNodeSpeed) {
        const scale = PHYSICS.maxNodeSpeed / v;
        n.vx *= scale;
        n.vy *= scale;
      }

      n.x += n.vx * PHYSICS.pxPerMeter * dt;
      n.y += n.vy * PHYSICS.pxPerMeter * dt;
      n.y = Math.min(n.y, canvas.height - 60);
      n.fx = 0;
      n.fy = n.mass * PHYSICS.gravity;
    }
  }

  for (const m of activeMembers) {
    if (canBreak && m.ratio > 1) m.overloadCount += 1;
    else m.overloadCount = Math.max(0, m.overloadCount - 1);

    if (canBreak && m.overloadCount >= PHYSICS.overloadFramesToFail) {
      m.broken = true;
      m.overloadCount = 0;
      if (!state.breakLog.some(i => i.id === m.id && i.type === 'member')) {
        state.breakLog.push({ type: 'member', id: m.id, order: state.nextBreakOrder++ });
        makeFragments((m.a.x + m.b.x) * 0.5, (m.a.y + m.b.y) * 0.5, m.mat.color);
      }
    }
  }
}

function bucklingLimit(m, L) {
  const I = (Math.PI * Math.pow(m.mat.radius, 4)) / 4;
  const euler = (Math.PI * Math.PI * m.mat.E * I) / Math.max(0.08 * 0.08, L * L);
  return Math.min(m.mat.compressive, euler / m.mat.area);
}

function drawGrid() {
  ctx.strokeStyle = 'rgba(0,0,0,0.05)'; ctx.lineWidth = 1;
  for (let x = 0; x < canvas.width; x += 40) { ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, canvas.height); ctx.stroke(); }
  for (let y = canvas.height; y > 0; y -= 40) { ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(canvas.width, y); ctx.stroke(); }
}

function drawLoadVisual() {
  if (!state.simulating || state.env.load <= 0) return;
  const alive = state.nodes.filter(n => !n.broken && !n.pinned);
  if (!alive.length) return;
  const topY = Math.min(...alive.map(n => n.y));
  const topNodes = alive.filter(n => n.y <= topY + 20);
  const cx = topNodes.reduce((s, n) => s + n.x, 0) / topNodes.length;
  const w = 100 + state.env.load * 1.2; const h = 14;
  ctx.fillStyle = 'rgba(127,140,141,.95)'; ctx.fillRect(cx - w * 0.5, topY - 24, w, h);
  ctx.fillStyle = '#34495e'; ctx.fillRect(cx - 40, topY - 80, 80, 46);
  ctx.fillStyle = '#ecf0f1'; ctx.font = 'bold 13px Segoe UI'; ctx.textAlign = 'center'; ctx.fillText(`${state.env.load}kg`, cx, topY - 50);
}

function drawScene() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = '#95a5a6'; ctx.fillRect(0, canvas.height - 60, canvas.width, 60);
  drawGrid();

  for (const m of state.members) {
    if (m.broken) continue;
    if (!state.simulating && m.wasBroken && m.breakOrder <= 3) {
      ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 6; ctx.beginPath(); ctx.moveTo(m.a.x, m.a.y); ctx.lineTo(m.b.x, m.b.y); ctx.stroke();
    }
    ctx.strokeStyle = m.mat.color; ctx.lineWidth = 3; ctx.lineCap = 'round'; ctx.beginPath(); ctx.moveTo(m.a.x, m.a.y); ctx.lineTo(m.b.x, m.b.y); ctx.stroke();
    if (state.simulating) {
      const alpha = Math.min(0.9, Math.abs(m.ratio));
      if (alpha > 0.02) {
        const c = m.forceN >= 0 ? `rgba(220,50,50,${alpha})` : `rgba(60,100,220,${alpha})`;
        ctx.strokeStyle = c; ctx.lineWidth = 1.7; ctx.beginPath();
        const dx = m.b.x - m.a.x, dy = m.b.y - m.a.y, L = Math.hypot(dx, dy) || 1;
        const nx = -(dy / L) * 4, ny = (dx / L) * 4;
        ctx.moveTo(m.a.x + nx, m.a.y + ny); ctx.lineTo(m.b.x + nx, m.b.y + ny); ctx.stroke();
      }
    }
  }

  if (!state.simulating && !state.deleting && state.hoverMember && !state.hoverNode) {
    ctx.globalAlpha = 0.4; ctx.strokeStyle = '#2ecc71'; ctx.lineWidth = 7; ctx.beginPath(); ctx.moveTo(state.hoverMember.a.x, state.hoverMember.a.y); ctx.lineTo(state.hoverMember.b.x, state.hoverMember.b.y); ctx.stroke(); ctx.globalAlpha = 1;
  }

  for (const n of state.nodes) {
    if (n.broken) continue;
    if (!state.simulating && n.wasBroken && n.breakOrder <= 3) { ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(n.x, n.y, 12, 0, Math.PI * 2); ctx.stroke(); }
    ctx.beginPath(); ctx.arc(n.x, n.y, n.pinned ? 8 : 5, 0, Math.PI * 2); ctx.fillStyle = n.pinned ? '#34495e' : MATERIALS[n.matIdx].color; ctx.fill();
  }

  if (state.dragging && state.dragStart) {
    const target = state.hoverNode || state.mouse;
    ctx.setLineDash([6, 6]); ctx.strokeStyle = MATERIALS[state.matIdx].color; ctx.lineWidth = 2.2; ctx.beginPath(); ctx.moveTo(state.dragStart.x, state.dragStart.y); ctx.lineTo(target.x, target.y); ctx.stroke(); ctx.setLineDash([]);
  }

  if (state.deleting && !state.simulating) {
    if (state.hoverMember) {
      ctx.setLineDash([6, 4]); ctx.strokeStyle = '#e67e22'; ctx.lineWidth = 8; ctx.beginPath(); ctx.moveTo(state.hoverMember.a.x, state.hoverMember.a.y); ctx.lineTo(state.hoverMember.b.x, state.hoverMember.b.y); ctx.stroke(); ctx.setLineDash([]);
    }
    if (state.hoverNode) {
      ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 3; ctx.beginPath(); ctx.arc(state.hoverNode.x, state.hoverNode.y, 13, 0, Math.PI * 2); ctx.stroke();
    }
  }

  drawLoadVisual();
  drawFragments();
}

function cleanupIsolatedNodes() {
  state.nodes = state.nodes.filter(n => n.pinned || state.members.some(m => !m.broken && (m.a === n || m.b === n)));
}

function updateStats() {
  const aliveNodes = state.nodes.filter(n => !n.broken);
  const aliveMembers = state.members.filter(m => !m.broken);
  const maxHeightM = aliveNodes.length ? Math.max(...aliveNodes.map(n => (canvas.height - 60 - n.y) / PHYSICS.pxPerMeter)) : 0;
  document.getElementById('height-indicator').textContent = `ğŸ”ï¸ æœ€é«˜ç‚¹ï¼š${(maxHeightM * 100).toFixed(0)} cm`;

  document.getElementById('count-node').textContent = state.nodes.length;
  let lengths = [0, 0, 0], maxRatio = 0;
  for (const m of state.members) {
    const lcm = m.l0 * 100 / PHYSICS.pxPerMeter;
    lengths[m.matIdx] += lcm;
    if (!m.broken) maxRatio = Math.max(maxRatio, Math.abs(m.ratio));
  }
  document.getElementById('stat-len-wood').textContent = `${lengths[0].toFixed(0)} cm`;
  document.getElementById('stat-len-steel').textContent = `${lengths[1].toFixed(0)} cm`;
  document.getElementById('stat-len-carbon').textContent = `${lengths[2].toFixed(0)} cm`;
  document.getElementById('stat-total-len').textContent = `${(lengths[0] + lengths[1] + lengths[2]).toFixed(0)} cm`;
  const cost = state.nodes.length * 50 + lengths[0] * 2 + lengths[1] * 8 + lengths[2] * 20;
  document.getElementById('cost-total').textContent = Math.round(cost);
  document.getElementById('max-stress').textContent = `${(maxRatio * 100).toFixed(1)}%`;

  if (state.simulating) {
    cleanupIsolatedNodes();
  }
}

function getHoverNode(x, y) {
  let best = null, dBest = 12;
  for (const n of state.nodes) { const d = Math.hypot(n.x - x, n.y - y); if (d < dBest) { dBest = d; best = n; } }
  return best;
}
function projectPoint(p, a, b) { const l2 = (a.x - b.x) ** 2 + (a.y - b.y) ** 2; if (!l2) return { x: a.x, y: a.y }; const t = Math.max(0, Math.min(1, ((p.x - a.x) * (b.x - a.x) + (p.y - a.y) * (b.y - a.y)) / l2)); return { x: a.x + (b.x - a.x) * t, y: a.y + (b.y - a.y) * t }; }
function getHoverMember(p) {
  let best = null, dBest = 11;
  for (const m of state.members) {
    const pr = projectPoint(p, m.a, m.b);
    const d = Math.hypot(pr.x - p.x, pr.y - p.y);
    if (d < dBest) { dBest = d; best = m; }
  }
  return best;
}

function splitMemberAt(member, x, y) {
  const n = addNode(x, y, false, state.matIdx);
  state.members = state.members.filter(m => m !== member);
  addMember(member.a, n, member.matIdx);
  addMember(n, member.b, member.matIdx);
  return n;
}

window.autoConnect = () => {
  if (state.simulating) return toast('æµ‹è¯•ä¸­ä¸å¯è‡ªåŠ¨è¿æ¥');
  saveHistory();
  const threshold = 130;
  for (let i = 0; i < state.nodes.length; i++) {
    for (let j = i + 1; j < state.nodes.length; j++) {
      const a = state.nodes[i], b = state.nodes[j];
      if (Math.hypot(a.x - b.x, a.y - b.y) < threshold) addMember(a, b, state.matIdx);
    }
  }
  toast('è‡ªåŠ¨è¿æ¥å®Œæˆ');
};

function toast(msg) { const el = document.getElementById('toast'); el.textContent = msg; el.style.opacity = '1'; setTimeout(() => { el.style.opacity = '0'; }, 1600); }

function beginSimulation() {
  if (!state.members.length) return toast('è¯·å…ˆæ­å»ºè‡³å°‘ä¸€æ ¹æ†ä»¶');
  state.blueprint = serialize();
  state.breakLog = []; state.nextBreakOrder = 1; state.fragments = []; state.simFrames = 0;
  state.nodes.forEach(n => { n.vx = 0; n.vy = 0; n.broken = false; n.wasBroken = false; n.breakOrder = 0; n.baseX = n.x; });
  state.members.forEach(m => { m.broken = false; m.wasBroken = false; m.breakOrder = 0; m.forceN = 0; m.ratio = 0; m.overloadCount = 0; });
  state.simulating = true;
  document.getElementById('btn-mode').textContent = 'â¹ï¸ åœæ­¢æµ‹è¯•';
  document.getElementById('btn-mode').className = 'mode-btn running';
  document.querySelectorAll('input[type=range]').forEach(r => r.disabled = false);
  document.getElementById('replay-banner').style.display = 'none';
}
function endSimulation() {
  state.simulating = false;
  state.simFrames = 0;
  document.getElementById('btn-mode').textContent = 'â–¶ï¸ å¼€å§‹æµ‹è¯•';
  document.getElementById('btn-mode').className = 'mode-btn';
  document.querySelectorAll('input[type=range]').forEach(r => { r.disabled = true; r.value = 0; });
  state.env = { wind: 0, quake: 0, load: 0 };
  ['wind', 'quake', 'load'].forEach(k => document.getElementById(`disp-${k}`).textContent = `0${k === 'load' ? 'kg' : 'çº§'}`);
  if (state.blueprint) restore(state.blueprint);

  for (const event of state.breakLog) {
    if (event.type === 'member') {
      const m = state.members.find(mm => mm.id === event.id);
      if (m) { m.wasBroken = true; m.breakOrder = event.order; }
    }
  }
  if (state.breakLog.length) {
    document.getElementById('replay-banner').style.display = 'block';
    toast('å¤ç›˜æ¨¡å¼ï¼šçº¢è‰²æ ‡è®°ä¸ºæœ€å…ˆæ–­è£‚å¤„');
  }
}
window.toggleSim = () => state.simulating ? endSimulation() : beginSimulation();

canvas.addEventListener('mousemove', (e) => {
  const r = canvas.getBoundingClientRect();
  state.mouse = { x: e.clientX - r.left, y: e.clientY - r.top };
  state.hoverNode = getHoverNode(state.mouse.x, state.mouse.y);
  state.hoverMember = state.hoverNode ? null : getHoverMember(state.mouse);
  if (state.deleting) canvas.style.cursor = 'cell';
  else if (state.hoverNode || state.hoverMember) canvas.style.cursor = 'pointer';
  else canvas.style.cursor = 'crosshair';
});

canvas.addEventListener('mousedown', (e) => {
  if (state.simulating) return toast('æµ‹è¯•ä¸­æ— æ³•ç¼–è¾‘');
  if (e.button === 2 || state.deleting) {
    if (state.hoverNode) {
      const pinnedCount = state.nodes.filter(n => n.pinned).length;
      if (state.hoverNode.pinned && pinnedCount <= 2) return toast('è‡³å°‘ä¿ç•™2ä¸ªåœ°åŸºèŠ‚ç‚¹');
      saveHistory();
      state.members = state.members.filter(m => m.a !== state.hoverNode && m.b !== state.hoverNode);
      state.nodes = state.nodes.filter(n => n !== state.hoverNode);
      cleanupIsolatedNodes();
      return;
    }
    if (state.hoverMember) {
      saveHistory();
      state.members = state.members.filter(m => m !== state.hoverMember);
      cleanupIsolatedNodes();
    }
    return;
  }

  if (state.hoverNode) {
    state.dragging = true;
    state.dragStart = state.hoverNode;
    return;
  }

  if (state.hoverMember) {
    saveHistory();
    const p = projectPoint(state.mouse, state.hoverMember.a, state.hoverMember.b);
    state.dragStart = splitMemberAt(state.hoverMember, p.x, p.y);
    state.dragging = true;
    return;
  }

  const ground = canvas.height - 60;
  const pinned = state.mouse.y >= ground - 15;
  const n = addNode(state.mouse.x, pinned ? ground : state.mouse.y, pinned, state.matIdx);
  if (pinned) n.baseX = n.x;
  state.dragStart = n;
  state.dragging = true;
});

canvas.addEventListener('mouseup', () => {
  if (!state.dragging) return;
  let target = state.hoverNode;
  if (!target && state.hoverMember) {
    saveHistory();
    const p = projectPoint(state.mouse, state.hoverMember.a, state.hoverMember.b);
    target = splitMemberAt(state.hoverMember, p.x, p.y);
  }
  if (!target) {
    const ground = canvas.height - 60;
    const pinned = state.mouse.y >= ground - 5;
    target = addNode(state.mouse.x, pinned ? ground : state.mouse.y, pinned, state.matIdx);
    if (pinned) target.baseX = target.x;
  }
  if (state.dragStart && target && state.dragStart !== target) {
    saveHistory();
    addMember(state.dragStart, target, state.matIdx);
  }
  state.dragging = false;
  state.dragStart = null;
});
canvas.addEventListener('contextmenu', (e) => e.preventDefault());

function frame() {
  if (state.simulating) evaluateStructure();
  drawScene();
  updateStats();
  requestAnimationFrame(frame);
}

resize();
window.addEventListener('resize', () => { resize(); if (!state.simulating && !state.nodes.length) initScene(); });
initScene();
frame();
</script>
</body>
</html>
