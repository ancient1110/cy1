<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>塔台工程二维模拟</title>
  <style>
    :root {
      --bg: #f5f7fb;
      --panel: #ffffff;
      --line: #3e4c6d;
      --stick: #9b6b3d;
      --stick-highlight: #be8551;
      --danger: #c0392b;
      --ok: #2d8a4f;
      --muted: #6c7a96;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "Microsoft YaHei", "PingFang SC", sans-serif;
      background: var(--bg);
      color: #1f2a44;
      display: grid;
      grid-template-columns: 340px 1fr;
      min-height: 100vh;
      gap: 12px;
      padding: 12px;
    }
    .panel {
      background: var(--panel);
      border-radius: 12px;
      box-shadow: 0 3px 12px rgba(0,0,0,0.08);
      padding: 14px;
    }
    .panel h1 {
      font-size: 20px;
      margin: 0 0 10px;
    }
    .section { margin-bottom: 14px; }
    .section h2 {
      font-size: 15px;
      margin: 0 0 8px;
      color: #304167;
    }
    .row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 7px 0;
    }
    .row label {
      width: 98px;
      color: #3f4f74;
      font-size: 13px;
    }
    input[type="range"] { flex: 1; }
    input[type="number"] {
      width: 64px;
      padding: 4px;
    }
    button {
      border: none;
      background: #4361ee;
      color: white;
      padding: 8px 10px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 13px;
    }
    button.secondary { background: #7b879f; }
    button.danger { background: #d94841; }
    button:active { transform: translateY(1px); }
    .stats {
      background: #f2f5ff;
      border-radius: 8px;
      padding: 10px;
      font-size: 14px;
      line-height: 1.7;
    }
    .stats strong { color: #20315a; }
    .ok { color: var(--ok); }
    .danger-text { color: var(--danger); }
    .hint {
      font-size: 12px;
      color: var(--muted);
      line-height: 1.5;
    }
    .canvas-wrap {
      background: var(--panel);
      border-radius: 12px;
      box-shadow: 0 3px 12px rgba(0,0,0,0.08);
      padding: 8px;
      display: flex;
      flex-direction: column;
    }
    canvas {
      width: 100%;
      height: calc(100vh - 50px);
      border-radius: 10px;
      background: linear-gradient(#f9fbff, #eef3ff 70%);
      border: 1px solid #d9e1f2;
      cursor: crosshair;
    }
    @media (max-width: 980px) {
      body { grid-template-columns: 1fr; }
      canvas { height: 62vh; }
    }
  </style>
</head>
<body>
  <aside class="panel">
    <h1>塔台工程互动模拟</h1>
    <div class="section">
      <h2>搭建工具</h2>
      <div class="row">
        <label>木条长度(px)</label>
        <input type="range" id="stickLength" min="35" max="140" value="78" />
        <span id="stickLengthVal">78</span>
      </div>
      <div class="row">
        <label>木条单价(元)</label>
        <input type="number" id="stickCost" min="1" max="50" value="6" />
      </div>
      <div class="row">
        <button id="undoBtn" class="secondary">撤销一步</button>
        <button id="clearBtn" class="danger">清空重建</button>
      </div>
      <p class="hint">点击画布添加节点，拖拽到另一个节点可连成木条。靠近地面可自动吸附，帮助搭建底座。</p>
    </div>

    <div class="section">
      <h2>环境测试</h2>
      <div class="row">
        <label>顶部重物(kg)</label>
        <input type="range" id="load" min="0" max="220" value="20" />
        <span id="loadVal">20</span>
      </div>
      <div class="row">
        <label>风力等级</label>
        <input type="range" id="wind" min="0" max="12" value="1" />
        <span id="windVal">1</span>
      </div>
      <div class="row">
        <label>地震强度</label>
        <input type="range" id="quake" min="0" max="10" value="0" />
        <span id="quakeVal">0</span>
      </div>
      <div class="row">
        <button id="testBtn">开始检验</button>
        <button id="pauseBtn" class="secondary">暂停扰动</button>
      </div>
    </div>

    <div class="section">
      <h2>实时数据</h2>
      <div class="stats">
        <div>木条数量：<strong id="sticksCount">0</strong></div>
        <div>塔台高度：<strong id="heightVal">0.00 m</strong></div>
        <div>总造价：<strong id="costVal">0 元</strong></div>
        <div>稳定评分：<strong id="stabilityVal">100</strong></div>
        <div>安全状态：<strong id="statusVal" class="ok">稳固</strong></div>
      </div>
    </div>

    <p class="hint">课堂建议：先让学生尝试不同底座宽度，再对比在相同风力和地震下的稳定评分变化，理解“三角结构”的优势。</p>
  </aside>

  <main class="canvas-wrap">
    <canvas id="simCanvas" width="1100" height="760"></canvas>
  </main>

  <script>
    const canvas = document.getElementById('simCanvas');
    const ctx = canvas.getContext('2d');

    const baseY = () => canvas.height - 60;
    const groundLeft = 40;
    const groundRight = () => canvas.width - 40;

    const nodes = [];
    const sticks = [];
    const history = [];

    let draggingNode = null;
    let hoverNode = null;
    let mouseX = 0;
    let mouseY = 0;

    let shakeTime = 0;
    let testing = false;

    const ui = {
      stickLength: document.getElementById('stickLength'),
      stickLengthVal: document.getElementById('stickLengthVal'),
      stickCost: document.getElementById('stickCost'),
      load: document.getElementById('load'),
      loadVal: document.getElementById('loadVal'),
      wind: document.getElementById('wind'),
      windVal: document.getElementById('windVal'),
      quake: document.getElementById('quake'),
      quakeVal: document.getElementById('quakeVal'),
      sticksCount: document.getElementById('sticksCount'),
      heightVal: document.getElementById('heightVal'),
      costVal: document.getElementById('costVal'),
      stabilityVal: document.getElementById('stabilityVal'),
      statusVal: document.getElementById('statusVal'),
      testBtn: document.getElementById('testBtn'),
      pauseBtn: document.getElementById('pauseBtn'),
      undoBtn: document.getElementById('undoBtn'),
      clearBtn: document.getElementById('clearBtn')
    };

    function syncLabels() {
      ui.stickLengthVal.textContent = ui.stickLength.value;
      ui.loadVal.textContent = ui.load.value;
      ui.windVal.textContent = ui.wind.value;
      ui.quakeVal.textContent = ui.quake.value;
    }

    ['input', 'change'].forEach(evt => {
      ui.stickLength.addEventListener(evt, syncLabels);
      ui.load.addEventListener(evt, syncLabels);
      ui.wind.addEventListener(evt, syncLabels);
      ui.quake.addEventListener(evt, syncLabels);
    });
    syncLabels();

    function distance(a, b) {
      return Math.hypot(a.x - b.x, a.y - b.y);
    }

    function toMeters(px) {
      return px / 85;
    }

    function nearestNode(x, y, maxDist = 16) {
      let best = null;
      let bestDist = maxDist;
      for (const n of nodes) {
        const d = Math.hypot(n.x - x, n.y - y);
        if (d < bestDist) {
          best = n;
          bestDist = d;
        }
      }
      return best;
    }

    function clampToGround(y) {
      return Math.abs(y - baseY()) < 14 ? baseY() : y;
    }

    function addNode(x, y) {
      const node = { x, y: clampToGround(y) };
      nodes.push(node);
      history.push({ type: 'node', node });
      return node;
    }

    function hasStick(a, b) {
      return sticks.some(s => (s.a === a && s.b === b) || (s.a === b && s.b === a));
    }

    function addStick(a, b) {
      if (!a || !b || a === b || hasStick(a, b)) return;
      sticks.push({ a, b });
      history.push({ type: 'stick' });
      updateStats();
    }

    function undo() {
      const last = history.pop();
      if (!last) return;
      if (last.type === 'stick') {
        sticks.pop();
      } else if (last.type === 'node') {
        const removed = nodes.pop();
        for (let i = sticks.length - 1; i >= 0; i--) {
          if (sticks[i].a === removed || sticks[i].b === removed) sticks.splice(i, 1);
        }
      }
      updateStats();
    }

    function clearAll() {
      nodes.length = 0;
      sticks.length = 0;
      history.length = 0;
      testing = false;
      updateStats();
    }

    function calculateHeightPx() {
      if (!nodes.length) return 0;
      let top = Infinity;
      for (const n of nodes) top = Math.min(top, n.y);
      return Math.max(0, baseY() - top);
    }

    function computeStability() {
      const load = Number(ui.load.value);
      const wind = Number(ui.wind.value);
      const quake = Number(ui.quake.value);
      const h = calculateHeightPx();

      const supportNodes = nodes.filter(n => n.y >= baseY() - 2).length;
      const baseWidth = (() => {
        const supports = nodes.filter(n => n.y >= baseY() - 2).map(n => n.x);
        if (supports.length < 2) return 30;
        return Math.max(...supports) - Math.min(...supports);
      })();

      const triangleLike = sticks.length > 0 ? (sticks.length / Math.max(1, nodes.length - 1)) : 0;

      let score = 100;
      score -= h * 0.11;
      score -= load * 0.18;
      score -= wind * 4.6;
      score -= quake * 6.2;
      score += Math.min(28, baseWidth * 0.09);
      score += Math.min(22, supportNodes * 4);
      score += Math.min(18, triangleLike * 10);

      return Math.max(0, Math.min(100, score));
    }

    function updateStats() {
      const hPx = calculateHeightPx();
      const hMeters = toMeters(hPx).toFixed(2);
      const unitCost = Math.max(1, Number(ui.stickCost.value) || 0);
      const totalCost = sticks.length * unitCost;
      const stability = computeStability();

      ui.sticksCount.textContent = String(sticks.length);
      ui.heightVal.textContent = `${hMeters} m`;
      ui.costVal.textContent = `${totalCost} 元`;
      ui.stabilityVal.textContent = stability.toFixed(0);

      let status = '稳固';
      let cls = 'ok';
      if (stability < 70) {
        status = '轻微晃动';
        cls = 'danger-text';
      }
      if (stability < 45) {
        status = '高风险';
        cls = 'danger-text';
      }
      if (stability < 25) {
        status = '可能倒塌';
        cls = 'danger-text';
      }

      ui.statusVal.textContent = status;
      ui.statusVal.className = cls;
    }

    function getTopNode() {
      if (!nodes.length) return null;
      return nodes.reduce((p, c) => (c.y < p.y ? c : p));
    }

    function drawGround(offsetX) {
      ctx.fillStyle = '#dce8ff';
      ctx.fillRect(groundLeft + offsetX, baseY(), groundRight() - groundLeft, 22);
      ctx.strokeStyle = '#95a4c8';
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(groundLeft + offsetX, baseY());
      ctx.lineTo(groundRight() + offsetX, baseY());
      ctx.stroke();
    }

    function draw() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const wind = Number(ui.wind.value);
      const quake = Number(ui.quake.value);
      const stability = computeStability();
      const swing = testing ? (Math.sin(shakeTime * (0.08 + quake * 0.02)) * (wind * 0.9 + quake * 1.3) * (1.2 - stability / 140)) : 0;

      drawGround(swing);

      for (const s of sticks) {
        const highStress = testing && stability < 55 && Math.random() < 0.08;
        ctx.strokeStyle = highStress ? '#d64747' : 'var(--stick)';
        ctx.lineWidth = 6;
        ctx.lineCap = 'round';
        ctx.beginPath();
        ctx.moveTo(s.a.x + swing, s.a.y);
        ctx.lineTo(s.b.x + swing, s.b.y);
        ctx.stroke();

        ctx.strokeStyle = 'var(--stick-highlight)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(s.a.x + swing, s.a.y);
        ctx.lineTo(s.b.x + swing, s.b.y);
        ctx.stroke();
      }

      for (const n of nodes) {
        ctx.fillStyle = n === hoverNode ? '#40548a' : '#26355d';
        ctx.beginPath();
        ctx.arc(n.x + swing, n.y, 5, 0, Math.PI * 2);
        ctx.fill();
      }

      if (draggingNode) {
        const len = Number(ui.stickLength.value);
        const angle = Math.atan2(mouseY - draggingNode.y, mouseX - draggingNode.x);
        const tx = draggingNode.x + Math.cos(angle) * len + swing;
        const ty = draggingNode.y + Math.sin(angle) * len;

        ctx.setLineDash([7, 7]);
        ctx.strokeStyle = '#4e6fca';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(draggingNode.x + swing, draggingNode.y);
        ctx.lineTo(tx, ty);
        ctx.stroke();
        ctx.setLineDash([]);
      }

      const top = getTopNode();
      if (top && Number(ui.load.value) > 0) {
        const load = Number(ui.load.value);
        const blockW = 22 + Math.min(52, load * 0.18);
        const blockH = 16 + Math.min(32, load * 0.1);

        ctx.fillStyle = '#444';
        ctx.fillRect(top.x - blockW / 2 + swing, top.y - blockH - 5, blockW, blockH);
        ctx.fillStyle = '#f7f7f7';
        ctx.font = '12px sans-serif';
        ctx.fillText(`${load}kg`, top.x - blockW / 2 + 4 + swing, top.y - 12);
      }

      if (testing && stability < 18 && nodes.length > 0 && sticks.length > 0) {
        ctx.fillStyle = 'rgba(205, 49, 49, 0.15)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
      }

      requestAnimationFrame(draw);
      shakeTime += 1;
    }

    canvas.addEventListener('mousemove', e => {
      const rect = canvas.getBoundingClientRect();
      mouseX = (e.clientX - rect.left) * (canvas.width / rect.width);
      mouseY = (e.clientY - rect.top) * (canvas.height / rect.height);
      hoverNode = nearestNode(mouseX, mouseY, 14);
    });

    canvas.addEventListener('mousedown', e => {
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const node = nearestNode(x, y, 14);
      if (node) {
        draggingNode = node;
      } else {
        addNode(x, y);
        updateStats();
      }
    });

    canvas.addEventListener('mouseup', e => {
      if (!draggingNode) return;
      const rect = canvas.getBoundingClientRect();
      const x = (e.clientX - rect.left) * (canvas.width / rect.width);
      const y = (e.clientY - rect.top) * (canvas.height / rect.height);
      const len = Number(ui.stickLength.value);

      let target = nearestNode(x, y, 14);
      if (!target) {
        const angle = Math.atan2(y - draggingNode.y, x - draggingNode.x);
        const nx = draggingNode.x + Math.cos(angle) * len;
        const ny = draggingNode.y + Math.sin(angle) * len;
        target = addNode(nx, ny);
      }

      addStick(draggingNode, target);
      draggingNode = null;
      updateStats();
    });

    ui.testBtn.addEventListener('click', () => {
      testing = true;
      updateStats();
    });

    ui.pauseBtn.addEventListener('click', () => {
      testing = false;
      updateStats();
    });

    ui.undoBtn.addEventListener('click', undo);
    ui.clearBtn.addEventListener('click', clearAll);
    ui.stickCost.addEventListener('input', updateStats);
    ui.load.addEventListener('input', updateStats);
    ui.wind.addEventListener('input', updateStats);
    ui.quake.addEventListener('input', updateStats);

    updateStats();
    draw();
  </script>
</body>
</html>
