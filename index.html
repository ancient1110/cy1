<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å…­å¹´çº§ç§‘å­¦ï¼šå¡”å°å·¥ç¨‹ v6.7 (ææ–™å¹³è¡¡è°ƒä¼˜+å‹é‡å¯è§†åŒ–)</title>
    <style>
        body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; margin: 0; overflow: hidden; background-color: #f0f2f5; display: flex; user-select: none; }
        
        #canvas-container {
            flex-grow: 1; height: 100vh; position: relative;
            background: radial-gradient(circle at center, #ffffff 0%, #eef2f3 100%);
            cursor: crosshair;
        }

        #sidebar {
            width: 360px; height: 100vh; background: #fff;
            border-left: 1px solid #dcdcdc; display: flex; flex-direction: column;
            box-shadow: -5px 0 15px rgba(0,0,0,0.05); z-index: 100;
        }

        .sidebar-scroll { padding: 20px; overflow-y: auto; flex-grow: 1; }

        h2 { font-size: 16px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 8px; margin: 20px 0 10px 0; display: flex; justify-content: space-between; align-items: center; }
        h2:first-child { margin-top: 0; }
        
        .mode-btn {
            width: 100%; padding: 15px; border: none; border-radius: 8px;
            font-size: 18px; font-weight: bold; cursor: pointer; color: white;
            transition: all 0.3s; margin-bottom: 20px;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 4px 10px rgba(46, 204, 113, 0.3);
        }
        .mode-btn.testing {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 10px rgba(231, 76, 60, 0.3);
        }
        .mode-btn:active { transform: scale(0.98); }

        .material-group { display: flex; gap: 8px; margin-bottom: 10px; }
        .mat-option {
            flex: 1; padding: 10px 5px; border: 2px solid #ecf0f1; border-radius: 6px;
            text-align: center; cursor: pointer; transition: all 0.2s; font-size: 12px;
            background: #f9f9f9;
        }
        .mat-option:hover { border-color: #bdc3c7; }
        .mat-option.active { border-color: #3498db; background: #ebf5fb; color: #2980b9; font-weight: bold; }
        .mat-color { width: 12px; height: 12px; border-radius: 50%; margin: 0 auto 5px; }

        .slider-group { margin-bottom: 15px; background: #f8f9fa; padding: 10px; border-radius: 6px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 13px; margin-bottom: 5px; color: #555; }
        input[type=range] { width: 100%; cursor: pointer; }
        
        .stat-row { display: flex; justify-content: space-between; font-size: 14px; margin-bottom: 8px; color: #555; }
        .total-cost { font-size: 24px; color: #e67e22; font-weight: bold; text-align: right; margin-top: 10px; }
        .formula-note { font-size: 12px; color: #7f8c8d; margin-top: 5px; border-top: 1px dashed #ccc; padding-top: 8px; }
        
        #toast {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            background: rgba(44, 62, 80, 0.85); color: white; padding: 8px 20px;
            border-radius: 30px; opacity: 0; transition: opacity 0.5s; pointer-events: none;
        }
        
        .btn-group { display: flex; gap: 8px; margin-top: 15px; }
        .btn-small {
            background: #ecf0f1; border: none; padding: 8px 0; border-radius: 4px;
            cursor: pointer; color: #7f8c8d; font-size: 12px; flex: 1;
        }
        .btn-small:hover { background: #ffeaa7; color: #d35400; }
        .btn-small.danger { background: #fde6e6; color: #c0392b; }
        .btn-small.danger:hover { background: #f5b7b1; }

        #delete-mode-toggle {
            background: #ecf0f1; border: 2px solid #bdc3c7; border-radius: 4px;
            padding: 8px; text-align: center; cursor: pointer; font-size: 12px; margin-top: 10px;
        }
        #delete-mode-toggle.active {
            background: #e74c3c; border-color: #c0392b; color: white;
        }

        .btn-special {
            background: #3498db; color: white; width: 100%; padding: 10px;
            border: none; border-radius: 4px; margin-top: 15px; cursor: pointer;
            font-size: 14px;
        }
        .btn-special:hover { background: #2980b9; }
    </style>
</head>
<body>

    <div id="canvas-container">
        <canvas id="simCanvas"></canvas>
        <div id="toast">æç¤ºä¿¡æ¯</div>
    </div>

    <div id="sidebar">
        <div class="sidebar-scroll">
            <button id="btn-mode" class="mode-btn" onclick="toggleSimulation()">â–¶ï¸ å¼€å§‹æµ‹è¯•</button>

            <h2>ğŸ—ï¸ ææ–™é€‰æ‹© (ç‚¹å‡»åˆ‡æ¢)</h2>
            <div class="material-group">
                <div class="mat-option active" onclick="setMaterial('wood')" id="mat-wood">
                    <div class="mat-color" style="background:#8e44ad"></div>
                    <div>æ™®é€šæœ¨æ¡<br>Â¥2/cm</div>
                </div>
                <div class="mat-option" onclick="setMaterial('steel')" id="mat-steel">
                    <div class="mat-color" style="background:#2c3e50"></div>
                    <div>åŠ å¼ºé’¢æ<br>Â¥8/cm</div>
                </div>
                <div class="mat-option" onclick="setMaterial('carbon')" id="mat-carbon">
                    <div class="mat-color" style="background:#2980b9"></div>
                    <div>ç¢³çº¤ç»´<br>Â¥20/cm</div>
                </div>
            </div>
            <div style="font-size:12px; color:#7f8c8d; margin-top:5px;">
                * å½“å‰é€‰æ‹©ææ–™å°†ç”¨äºæ–°å»ºçš„æœ¨æ¡å’ŒèŠ‚ç‚¹ã€‚
            </div>

            <h2>ğŸ›ï¸ ç¯å¢ƒæµ‹è¯•å°</h2>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸ’¨ é£åŠ›ç­‰çº§</span> <span id="val-wind">0çº§</span></div>
                <input type="range" min="0" max="100" value="0" oninput="updateEnv('wind', this.value)" disabled id="slider-wind">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>ğŸŒ‹ åœ°éœ‡å¼ºåº¦</span> <span id="val-quake">0çº§</span></div>
                <input type="range" min="0" max="100" value="0" oninput="updateEnv('quake', this.value)" disabled id="slider-quake">
            </div>
            <div class="slider-group">
                <div class="slider-label"><span>âš–ï¸ é¡¶éƒ¨å‹é‡</span> <span id="val-load">0kg</span></div>
                <input type="range" min="0" max="100" value="0" oninput="updateEnv('load', this.value)" disabled id="slider-load">
            </div>

            <h2>ğŸ“Š å·¥ç¨‹é€ ä»·å•</h2>
            <div class="stat-row"><span>èŠ‚ç‚¹æ•°é‡:</span> <span id="stat-nodes">0</span> Ã— Â¥50</div>
            <div class="stat-row"><span>æ†ä»¶æ€»é•¿:</span> <span id="stat-total-length">0 cm</span></div>
            <div class="stat-row"><span>æœ¨æ¡é•¿åº¦:</span> <span id="stat-len-wood">0 cm</span> (Â¥2/cm)</div>
            <div class="stat-row"><span>é’¢æé•¿åº¦:</span> <span id="stat-len-steel">0 cm</span> (Â¥8/cm)</div>
            <div class="stat-row"><span>ç¢³çº¤é•¿åº¦:</span> <span id="stat-len-carbon">0 cm</span> (Â¥20/cm)</div>
            <div class="total-cost">Â¥<span id="stat-cost">0</span></div>
            <div class="formula-note">
                <strong>è®¡ç®—å…¬å¼ï¼š</strong><br>
                èŠ‚ç‚¹æˆæœ¬ = èŠ‚ç‚¹æ•° Ã— Â¥50<br>
                æ†ä»¶æˆæœ¬ = Î£(å„ææ–™é•¿åº¦ Ã— å•ä»·)<br>
                æ€»é€ ä»· = èŠ‚ç‚¹æˆæœ¬ + æ†ä»¶æˆæœ¬
            </div>

            <div style="display: flex; gap: 8px; margin: 20px 0 10px;">
                <button class="btn-small" onclick="undo()">â†©ï¸ æ’¤é”€</button>
                <button class="btn-small danger" onclick="clearAll()">ğŸ—‘ï¸ å…¨éƒ¨æ¸…ç©º</button>
            </div>
            <div id="delete-mode-toggle" onclick="toggleDeleteMode()">âœ‚ï¸ åˆ é™¤æ¨¡å¼ (å…³é—­)</div>
            
            <button class="btn-special" onclick="autoConnectIntersections()">ğŸ”— è‡ªåŠ¨è¿æ¥äº¤å‰ç‚¹</button>
        </div>
    </div>

<script>
    (function() {
        // --- å…¨å±€å˜é‡å®šä¹‰ ---
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvas-container');

        // --- ææ–™åº“ ---
        const MATERIALS = {
            wood:   { id: 'wood',   name: 'æœ¨æ¡', color: '#8e44ad', cost: 2,  strength: 6,  nodeStrength: 8,  mass: 0.14, angleStrength: 0.22 },
            steel:  { id: 'steel',  name: 'é’¢æ', color: '#2c3e50', cost: 8,  strength: 11, nodeStrength: 14, mass: 0.16, angleStrength: 0.32 },
            carbon: { id: 'carbon', name: 'ç¢³çº¤', color: '#2980b9', cost: 20, strength: 16, nodeStrength: 18, mass: 0.08, angleStrength: 0.45 }
        };

        const CONFIG = {
            gravity: 0.5,
            groundHeight: 60,
            snapDist: 15,
            maxStickLen: 120,
            scale: 10,
            nodeBaseCost: 50,
            angleStiffness: 0.1,
            angleIterations: 3
        };

        // --- å…¨å±€çŠ¶æ€ ---
        let width, height, groundY;
        let points = [];
        let sticks = [];
        let isSimulating = false;
        let currentMat = 'wood';
        let blueprint = null;                // å­˜å‚¨æµ‹è¯•å¼€å§‹çš„å®Œå¥½çŠ¶æ€
        let env = { wind: 0, quake: 0, load: 0 };
        let mouse = { x: 0, y: 0 };
        let dragStart = null;
        let isDragging = false;
        let hoveredPoint = null;
        let hoveredStick = null;              // ç”¨äºåˆ é™¤æ¨¡å¼
        let preheatRemaining = 0;
        let angleConstraints = [];

        // æ–­è£‚é¡ºåºè®°å½•
        let nextBreakOrder = 1;                // ä¸‹ä¸€ä¸ªæ–­è£‚åºå·
        const MAX_BREAKS_TO_HIGHLIGHT = 3;      // æœ€å¤šæ ‡æ³¨å‰ä¸‰ä¸ª

        // å†å²è®°å½•
        let historyStack = [];
        const MAX_HISTORY = 20;

        // åˆ é™¤æ¨¡å¼
        let deleteMode = false;

        function getWindForceAtY(y) {
            if (!isSimulating || env.wind <= 0) return 0;
            const amplitude = (groundY - y) / 1000 * (env.wind / 20);
            const phase = Date.now() / 350;
            return Math.sin(phase) * amplitude;
        }

        function getQuakeOffsets() {
            if (!isSimulating || env.quake <= 0) return { x: 0, y: 0 };
            const t = Date.now();
            const xAmp = env.quake / 5;
            const yAmp = env.quake / 8;
            return {
                x: Math.sin(t / 50) * xAmp,
                y: Math.cos(t / 65) * yAmp
            };
        }

        // --- ç‚¹ç±» ---
        class Point {
            constructor(x, y, pinned, matId) {
                this.x = x; this.y = y;
                this.oldx = x; this.oldy = y;
                this.pinned = pinned;
                this.mat = MATERIALS[matId];
                this.baseX = x;
                this.broken = false;          // å½“å‰æ˜¯å¦æŠ˜æ–­ï¼ˆç‰©ç†æ¨¡æ‹Ÿç”¨ï¼‰
                this.wasBroken = false;        // å†å²æ˜¯å¦æŠ˜æ–­è¿‡
                this.breakOrder = 0;            // æ–­è£‚é¡ºåºï¼Œ0è¡¨ç¤ºæœªæ–­è£‚
            }

            update() {
                if (this.broken) {
                    let vx = (this.x - this.oldx) * 0.98;
                    let vy = (this.y - this.oldy) * 0.98;

                    this.oldx = this.x;
                    this.oldy = this.y;

                    this.y += CONFIG.gravity;

                    this.x += getWindForceAtY(this.y);

                    this.x += vx;
                    this.y += vy;

                    if (this.y > groundY) {
                        this.y = groundY;
                        this.oldy = this.y + vy * 0.5;
                    }
                    return;
                }

                if (!isSimulating) {
                    this.oldx = this.x;
                    this.oldy = this.y;
                    return;
                }

                if (this.pinned) {
                    const quake = getQuakeOffsets();
                    if (env.quake > 0) {
                        this.x = this.baseX + quake.x;
                        this.y = groundY + quake.y;
                    } else {
                        this.x += (this.baseX - this.x) * 0.1;
                        this.y = groundY;
                    }
                    this.oldx = this.x;
                    this.oldy = this.y;
                    return;
                }

                let vx = (this.x - this.oldx) * 0.98;
                let vy = (this.y - this.oldy) * 0.98;

                this.oldx = this.x;
                this.oldy = this.y;

                this.y += CONFIG.gravity * this.mat.mass;

                if (groundY - this.y > 100) {
                    this.y += (env.load * 0.08);
                }

                this.x += getWindForceAtY(this.y);

                this.x += vx;
                this.y += vy;

                if (this.y > groundY) {
                    this.y = groundY;
                    this.oldy = this.y + vy * 0.5;
                }
            }
        }

        // --- æ†ä»¶ç±» ---
        class Stick {
            constructor(p1, p2, matId) {
                this.p1 = p1;
                this.p2 = p2;
                this.mat = MATERIALS[matId];
                this.len = Math.hypot(p1.x - p2.x, p1.y - p2.y);
                this.stress = 0;
                this.broken = false;           // å½“å‰æ˜¯å¦æŠ˜æ–­
                this.wasBroken = false;         // å†å²æ˜¯å¦æŠ˜æ–­è¿‡
                this.breakOrder = 0;             // æ–­è£‚é¡ºåº
            }

            update() {
                if (this.broken) return;

                if (!isSimulating) {
                    this.len = Math.hypot(this.p1.x - this.p2.x, this.p1.y - this.p2.y);
                    return;
                }

                let dx = this.p2.x - this.p1.x;
                let dy = this.p2.y - this.p1.y;
                let dist = Math.hypot(dx, dy);
                if (dist === 0) return;

                this.stress = Math.abs(dist - this.len);

                if (preheatRemaining <= 0) {
                    // æ†ä»¶è‡ªèº«å¼ºåº¦æ–­è£‚
                    if (this.stress > this.mat.strength && !this.broken) {
                        this.broken = true;
                        this.wasBroken = true;
                        this.breakOrder = nextBreakOrder++;
                    }

                    // èŠ‚ç‚¹å¼ºåº¦æ–­è£‚ï¼ˆæ‹‰åŠ›ç ´åï¼‰
                    if (this.stress > Math.min(this.p1.mat.nodeStrength, this.p2.mat.nodeStrength)) {
                        if (this.p1.mat.nodeStrength < this.stress && !this.p1.pinned && !this.p1.broken) {
                            this.p1.broken = true;
                            this.p1.wasBroken = true;
                            this.p1.breakOrder = nextBreakOrder++;
                        }
                        if (this.p2.mat.nodeStrength < this.stress && !this.p2.pinned && !this.p2.broken) {
                            this.p2.broken = true;
                            this.p2.wasBroken = true;
                            this.p2.breakOrder = nextBreakOrder++;
                        }
                    }
                }

                let diff = this.len - dist;
                let percent = diff / dist / 2;
                let ox = dx * percent;
                let oy = dy * percent;

                if (!this.p1.pinned) { this.p1.x -= ox; this.p1.y -= oy; }
                if (!this.p2.pinned) { this.p2.x += ox; this.p2.y += oy; }
            }

            draw() {
                // åœæ­¢æµ‹è¯•åï¼Œå¦‚æœæ›¾ç»æ–­è£‚ä¸”æ–­è£‚é¡ºåº <= MAX_BREAKS_TO_HIGHLIGHTï¼Œç”¨é†’ç›®çº¢è‰²æ ‡æ³¨
                if (!isSimulating && this.wasBroken && this.breakOrder > 0 && this.breakOrder <= MAX_BREAKS_TO_HIGHLIGHT) {
                    // çº¢è‰²ç²—å¤–è½®å»“ + åŸè‰²å†…çº¿
                    ctx.beginPath();
                    ctx.moveTo(this.p1.x, this.p1.y);
                    ctx.lineTo(this.p2.x, this.p2.y);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 8;
                    ctx.setLineDash([]);
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.moveTo(this.p1.x, this.p1.y);
                    ctx.lineTo(this.p2.x, this.p2.y);
                    ctx.strokeStyle = this.mat.color;
                    ctx.lineWidth = 4;
                    ctx.stroke();
                    return;
                }

                // æ¨¡æ‹Ÿä¸­æˆ–æœªæ–­è£‚çš„æ­£å¸¸ç»˜åˆ¶
                if (this.broken) {
                    // æ¨¡æ‹Ÿä¸­æ–­è£‚çš„æ„ä»¶åªç”¨åŸè‰²ç»˜åˆ¶
                    ctx.beginPath();
                    ctx.moveTo(this.p1.x, this.p1.y);
                    ctx.lineTo(this.p2.x, this.p2.y);
                    ctx.strokeStyle = this.mat.color;
                    ctx.lineWidth = 4;
                    ctx.setLineDash([]);
                    ctx.stroke();
                    return;
                }

                // æ­£å¸¸æ†ä»¶
                ctx.beginPath();
                let color = this.mat.color;
                let width = 4;

                if (isSimulating) {
                    let ratio = Math.min(this.stress / (this.mat.strength * 0.8), 1);
                    if (ratio > 0.5) {
                        ctx.strokeStyle = `rgb(255, ${200 * (1-ratio)}, 0)`;
                    } else {
                        ctx.strokeStyle = color;
                    }
                } else {
                    ctx.strokeStyle = color;
                }

                ctx.lineWidth = width;
                ctx.lineCap = 'round';
                ctx.moveTo(this.p1.x, this.p1.y);
                ctx.lineTo(this.p2.x, this.p2.y);
                ctx.stroke();
            }
        }

        // --- åˆå§‹åŒ– ---
        function init() {
            resize();
            window.addEventListener('resize', resize);
            addPoint(width/2 - 60, groundY, true, 'wood');
            addPoint(width/2 + 60, groundY, true, 'wood');
            saveHistory(); // åˆå§‹çŠ¶æ€ä¿å­˜
            loop();
        }

        function resize() {
            width = container.clientWidth;
            height = container.clientHeight;
            canvas.width = width;
            canvas.height = height;
            groundY = height - CONFIG.groundHeight;
            points.forEach(p => { if(p.pinned) p.y = groundY; });
        }

        function addPoint(x, y, pinned, matId) {
            let p = new Point(x, y, pinned, matId);
            points.push(p);
            return p;
        }

        // --- å†å²è®°å½• ---
        function saveHistory() {
            let snapshot = {
                points: points.map(p => ({
                    x: p.x, y: p.y, pinned: p.pinned, matId: p.mat.id,
                    broken: p.broken, wasBroken: p.wasBroken, breakOrder: p.breakOrder
                })),
                sticks: sticks.map(s => {
                    let p1Idx = points.indexOf(s.p1);
                    let p2Idx = points.indexOf(s.p2);
                    return {
                        p1Idx, p2Idx,
                        matId: s.mat.id,
                        broken: s.broken, wasBroken: s.wasBroken, breakOrder: s.breakOrder,
                        len: s.len
                    };
                })
            };
            historyStack.push(snapshot);
            if (historyStack.length > MAX_HISTORY) historyStack.shift();
        }

        function restoreFromHistory(snapshot) {
            points = snapshot.points.map(p => {
                let pt = new Point(p.x, p.y, p.pinned, p.matId);
                pt.broken = p.broken;
                pt.wasBroken = p.wasBroken;
                pt.breakOrder = p.breakOrder;
                return pt;
            });
            sticks = snapshot.sticks.map(s => {
                let p1 = points[s.p1Idx];
                let p2 = points[s.p2Idx];
                let st = new Stick(p1, p2, s.matId);
                st.broken = s.broken;
                st.wasBroken = s.wasBroken;
                st.breakOrder = s.breakOrder;
                st.len = s.len || Math.hypot(p1.x - p2.x, p1.y - p2.y);
                return st;
            });
            angleConstraints = [];
        }

        function undo() {
            if (isSimulating) { showToast("æµ‹è¯•ä¸­ä¸èƒ½æ’¤é”€"); return; }
            if (historyStack.length <= 1) { showToast("æ²¡æœ‰æ›´å¤šæ­¥éª¤"); return; }
            historyStack.pop();
            let prev = historyStack[historyStack.length-1];
            restoreFromHistory(prev);
            showToast("æ’¤é”€æˆåŠŸ");
        }

        // --- åˆ é™¤æ¨¡å¼ ---
        function toggleDeleteMode() {
            if (isSimulating) { showToast("æµ‹è¯•ä¸­ä¸èƒ½åˆ é™¤"); return; }
            deleteMode = !deleteMode;
            document.getElementById('delete-mode-toggle').innerText = deleteMode ? 'âœ‚ï¸ åˆ é™¤æ¨¡å¼ (å¼€å¯)' : 'âœ‚ï¸ åˆ é™¤æ¨¡å¼ (å…³é—­)';
            document.getElementById('delete-mode-toggle').classList.toggle('active', deleteMode);
        }

        function deletePoint(point) {
            let idx = points.indexOf(point);
            if (idx === -1) return;
            sticks = sticks.filter(s => s.p1 !== point && s.p2 !== point);
            points.splice(idx, 1);
        }

        function deleteStick(stick) {
            let idx = sticks.indexOf(stick);
            if (idx !== -1) sticks.splice(idx, 1);
        }

        // --- è‡ªåŠ¨è¿æ¥äº¤å‰ç‚¹ (ç¨³å¥ç‰ˆ) ---
        function autoConnectIntersections() {
            if (isSimulating) { showToast("æµ‹è¯•ä¸­ä¸èƒ½ä½¿ç”¨æ­¤åŠŸèƒ½"); return; }
            if (sticks.length < 2) { showToast("è‡³å°‘éœ€è¦ä¸¤æ ¹æ†ä»¶"); return; }

            saveHistory(); // è®°å½•æ“ä½œå‰çŠ¶æ€

            const EPS = 1e-4;
            const ENDPOINT_GUARD = 0.02;
            const MERGE_TOL = Math.max(2, CONFIG.snapDist * 0.25);

            const clusters = [];
            const splitMap = new Map(); // stick -> [{ t, point }]

            function pointLineDistance(px, py, ax, ay, bx, by) {
                const vx = bx - ax;
                const vy = by - ay;
                const len2 = vx * vx + vy * vy;
                if (len2 < EPS) return Math.hypot(px - ax, py - ay);
                const t = ((px - ax) * vx + (py - ay) * vy) / len2;
                const clamped = Math.max(0, Math.min(1, t));
                const cx = ax + clamped * vx;
                const cy = ay + clamped * vy;
                return Math.hypot(px - cx, py - cy);
            }

            function findNearbyNode(ix, iy, s1, s2) {
                let nearest = null;
                let bestDist = CONFIG.snapDist;
                for (let p of points) {
                    const d = Math.hypot(p.x - ix, p.y - iy);
                    if (d >= bestDist) continue;
                    const dToS1 = pointLineDistance(p.x, p.y, s1.p1.x, s1.p1.y, s1.p2.x, s1.p2.y);
                    const dToS2 = pointLineDistance(p.x, p.y, s2.p1.x, s2.p1.y, s2.p2.x, s2.p2.y);
                    if (dToS1 > MERGE_TOL || dToS2 > MERGE_TOL) continue;
                    nearest = p;
                    bestDist = d;
                }
                return nearest;
            }

            function findOrCreateCluster(x, y, existingNode) {
                for (let c of clusters) {
                    if (Math.hypot(c.x - x, c.y - y) <= MERGE_TOL) {
                        if (!c.existingNode && existingNode) c.existingNode = existingNode;
                        if (c.existingNode) {
                            c.x = c.existingNode.x;
                            c.y = c.existingNode.y;
                        }
                        return c;
                    }
                }
                const cluster = {
                    x: existingNode ? existingNode.x : x,
                    y: existingNode ? existingNode.y : y,
                    existingNode,
                    node: null
                };
                clusters.push(cluster);
                return cluster;
            }

            function registerSplit(stick, t, cluster) {
                if (t <= ENDPOINT_GUARD || t >= 1 - ENDPOINT_GUARD) return;
                if (!splitMap.has(stick)) splitMap.set(stick, []);
                splitMap.get(stick).push({ t, cluster });
            }

            // 1) æ£€æµ‹æ‰€æœ‰äº¤ç‚¹å¹¶æ³¨å†Œåˆ°å¯¹åº”æ†ä»¶
            for (let i = 0; i < sticks.length; i++) {
                for (let j = i + 1; j < sticks.length; j++) {
                    const s1 = sticks[i];
                    const s2 = sticks[j];
                    if (s1.p1 === s2.p1 || s1.p1 === s2.p2 || s1.p2 === s2.p1 || s1.p2 === s2.p2) continue;

                    const p1 = s1.p1, p2 = s1.p2, p3 = s2.p1, p4 = s2.p2;
                    const denom = (p4.y - p3.y) * (p2.x - p1.x) - (p4.x - p3.x) * (p2.y - p1.y);
                    if (Math.abs(denom) < EPS) continue;

                    const ua = ((p4.x - p3.x) * (p1.y - p3.y) - (p4.y - p3.y) * (p1.x - p3.x)) / denom;
                    const ub = ((p2.x - p1.x) * (p1.y - p3.y) - (p2.y - p1.y) * (p1.x - p3.x)) / denom;

                    if (ua <= ENDPOINT_GUARD || ua >= 1 - ENDPOINT_GUARD || ub <= ENDPOINT_GUARD || ub >= 1 - ENDPOINT_GUARD) continue;

                    const ix = p1.x + ua * (p2.x - p1.x);
                    const iy = p1.y + ua * (p2.y - p1.y);
                    const nearbyNode = findNearbyNode(ix, iy, s1, s2);
                    const cluster = findOrCreateCluster(ix, iy, nearbyNode);

                    registerSplit(s1, ua, cluster);
                    registerSplit(s2, ub, cluster);
                }
            }

            let newNodesCount = 0;
            let processedSticks = 0;

            // 2) ä¸ºæ¯ä¸ªäº¤ç‚¹å‡†å¤‡å®é™…èŠ‚ç‚¹
            for (let cluster of clusters) {
                cluster.node = cluster.existingNode || addPoint(cluster.x, cluster.y, false, currentMat);
                if (!cluster.existingNode) newNodesCount++;
            }

            // 3) å¯¹æ¯æ ¹æ†ä»¶æŒ‰ t å€¼å¤šæ®µæ‹†åˆ†ï¼ˆæ”¯æŒä¸€æ ¹æ†ä»¶å¤šä¸ªäº¤ç‚¹ï¼‰
            for (let [stick, splits] of splitMap.entries()) {
                if (!splits.length) continue;

                const deduped = [];
                splits.sort((a, b) => a.t - b.t);
                for (let s of splits) {
                    const last = deduped[deduped.length - 1];
                    if (last && Math.abs(last.t - s.t) < ENDPOINT_GUARD) continue;
                    deduped.push(s);
                }
                if (!deduped.length) continue;

                const idx = sticks.indexOf(stick);
                if (idx === -1) continue;
                sticks.splice(idx, 1);

                let chain = [stick.p1, ...deduped.map(s => s.cluster.node), stick.p2];
                for (let i = 0; i < chain.length - 1; i++) {
                    const a = chain[i];
                    const b = chain[i + 1];
                    if (a === b) continue;
                    if (Math.hypot(a.x - b.x, a.y - b.y) < 0.5) continue;
                    sticks.push(new Stick(a, b, stick.mat.id));
                }
                processedSticks++;
            }

            if (newNodesCount > 0 || processedSticks > 0) {
                showToast(`å·²å¤„ç† ${processedSticks} æ ¹æ†ä»¶ï¼Œæ–°å¢ ${newNodesCount} ä¸ªèŠ‚ç‚¹`);
            } else {
                showToast("æœªå‘ç°éœ€è¦è¿æ¥çš„äº¤å‰ç‚¹");
            }
        }

        // --- è§’åº¦çº¦æŸæ„å»º ---
        function buildAngleConstraints() {
            angleConstraints = [];
            for (let node of points) {
                if (node.broken) continue;
                let neighbors = [];
                for (let s of sticks) {
                    if (s.broken) continue;
                    let other = null;
                    if (s.p1 === node) other = s.p2;
                    else if (s.p2 === node) other = s.p1;
                    if (!other || other.broken) continue;

                    let dx = other.x - node.x;
                    let dy = other.y - node.y;
                    let len = Math.hypot(dx, dy);
                    if (len < 0.01) continue;
                    let dirX = dx / len;
                    let dirY = dy / len;
                    neighbors.push({
                        point: other,
                        initDirX: dirX,
                        initDirY: dirY
                    });
                }
                if (neighbors.length >= 2) {
                    angleConstraints.push({ node, neighbors });
                }
            }
        }

        function applyAngleConstraints(iterations) {
            let stiffness = CONFIG.angleStiffness;
            for (let iter = 0; iter < iterations; iter++) {
                for (let c of angleConstraints) {
                    let node = c.node;
                    if (node.broken) continue;
                    for (let nb of c.neighbors) {
                        let p = nb.point;
                        if (p.broken) continue;
                        if (node.pinned && p.pinned) continue;

                        let dx = p.x - node.x;
                        let dy = p.y - node.y;
                        let dist = Math.hypot(dx, dy);
                        if (dist < 0.01) continue;

                        let tx = nb.initDirX;
                        let ty = nb.initDirY;

                        let targetX = node.x + tx * dist;
                        let targetY = node.y + ty * dist;

                        let moveX = (targetX - p.x) * stiffness;
                        let moveY = (targetY - p.y) * stiffness;

                        if (!node.pinned && !p.pinned) {
                            p.x += moveX;
                            p.y += moveY;
                            node.x -= moveX;
                            node.y -= moveY;
                            p.oldx = p.x;
                            p.oldy = p.y;
                            node.oldx = node.x;
                            node.oldy = node.y;
                        } else if (!p.pinned) {
                            p.x += moveX;
                            p.y += moveY;
                            p.oldx = p.x;
                            p.oldy = p.y;
                        } else if (!node.pinned) {
                            node.x -= moveX;
                            node.y -= moveY;
                            node.oldx = node.x;
                            node.oldy = node.y;
                        }
                    }
                }
            }
        }

        function checkAngleBreaks() {
            let newBroken = false;
            for (let c of angleConstraints) {
                let node = c.node;
                if (node.broken) continue;
                let maxAngleDiff = 0;
                let neighbors = c.neighbors;
                for (let i = 0; i < neighbors.length; i++) {
                    for (let j = i+1; j < neighbors.length; j++) {
                        let a = neighbors[i];
                        let b = neighbors[j];
                        let ax = a.point.x - node.x;
                        let ay = a.point.y - node.y;
                        let bx = b.point.x - node.x;
                        let by = b.point.y - node.y;
                        let lenA = Math.hypot(ax, ay);
                        let lenB = Math.hypot(bx, by);
                        if (lenA < 0.01 || lenB < 0.01) continue;
                        let dot = ax*bx + ay*by;
                        let cross = ax*by - ay*bx;
                        let curAngle = Math.atan2(cross, dot);

                        let initDot = a.initDirX*b.initDirX + a.initDirY*b.initDirY;
                        let initCross = a.initDirX*b.initDirY - a.initDirY*b.initDirX;
                        let initAngle = Math.atan2(initCross, initDot);

                        let diff = Math.abs(curAngle - initAngle);
                        if (diff > Math.PI) diff = 2*Math.PI - diff;
                        if (diff > maxAngleDiff) maxAngleDiff = diff;
                    }
                }
                if (maxAngleDiff > node.mat.angleStrength && !node.broken) {
                    node.broken = true;
                    node.wasBroken = true;
                    node.breakOrder = nextBreakOrder++;
                    node.pinned = false;
                    newBroken = true;
                }
            }
            if (newBroken) {
                angleConstraints = angleConstraints.filter(c => !c.node.broken);
            }
        }

        // --- ä¸»å¾ªç¯ ---
        function loop() {
            let iter = isSimulating ? 5 : 1;

            if (preheatRemaining > 0) {
                let steps = Math.min(5, preheatRemaining);
                for (let s = 0; s < steps; s++) {
                    for (let k = 0; k < iter; k++) {
                        points.forEach(p => p.update());
                        sticks.forEach(s => s.update());
                        if (isSimulating && angleConstraints.length > 0) {
                            applyAngleConstraints(1);
                        }
                    }
                    preheatRemaining--;
                }
            } else {
                for (let k = 0; k < iter; k++) {
                    points.forEach(p => p.update());
                    sticks.forEach(s => s.update());
                    if (isSimulating && angleConstraints.length > 0) {
                        applyAngleConstraints(1);
                    }
                }
                if (isSimulating && angleConstraints.length > 0) {
                    applyAngleConstraints(CONFIG.angleIterations);
                    checkAngleBreaks();
                }
            }

            ctx.clearRect(0, 0, width, height);
            drawGrid();

            ctx.fillStyle = "#95a5a6";
            ctx.fillRect(0, groundY, width, CONFIG.groundHeight);

            drawLoadVisual();
            sticks.forEach(s => s.draw());

            points.forEach(p => {
                if (!isSimulating && p.wasBroken && p.breakOrder > 0 && p.breakOrder <= MAX_BREAKS_TO_HIGHLIGHT) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 10, 0, Math.PI*2);
                    ctx.strokeStyle = '#ff0000';
                    ctx.lineWidth = 3;
                    ctx.stroke();

                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                    ctx.fillStyle = p.mat.color;
                    ctx.fill();
                    return;
                }

                if (p.broken) {
                    ctx.beginPath();
                    ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
                    ctx.fillStyle = p.mat.color;
                    ctx.fill();
                    return;
                }

                ctx.beginPath();
                ctx.arc(p.x, p.y, p.pinned ? 8 : 5, 0, Math.PI*2);
                ctx.fillStyle = p.pinned ? "#34495e" : p.mat.color;
                ctx.fill();
                ctx.strokeStyle = "rgba(255,255,255,0.5)";
                ctx.lineWidth = 1;
                ctx.stroke();
            });

            if (deleteMode && !isSimulating) {
                hoveredStick = null;
                let stickDist = 10;
                for (let s of sticks) {
                    let d = distanceToSegment(mouse, s.p1, s.p2);
                    if (d < stickDist) {
                        stickDist = d;
                        hoveredStick = s;
                    }
                }
                if (hoveredStick) {
                    ctx.beginPath();
                    ctx.moveTo(hoveredStick.p1.x, hoveredStick.p1.y);
                    ctx.lineTo(hoveredStick.p2.x, hoveredStick.p2.y);
                    ctx.strokeStyle = '#e67e22';
                    ctx.lineWidth = 8;
                    ctx.setLineDash([5,5]);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }

            if (!isSimulating) drawInteraction();

            updateStats();
            requestAnimationFrame(loop);
        }

        function distanceToSegment(p, a, b) {
            let abx = b.x - a.x, aby = b.y - a.y;
            let apx = p.x - a.x, apy = p.y - a.y;
            let ab2 = abx*abx + aby*aby;
            if (ab2 === 0) return Math.hypot(p.x - a.x, p.y - a.y);
            let t = (apx*abx + apy*aby) / ab2;
            t = Math.max(0, Math.min(1, t));
            let projx = a.x + abx * t;
            let projy = a.y + aby * t;
            return Math.hypot(p.x - projx, p.y - projy);
        }

        function getTopCluster() {
            const active = points.filter(p => !p.broken);
            if (!active.length) return null;
            const topY = active.reduce((m, p) => Math.min(m, p.y), active[0].y);
            const band = active.filter(p => p.y <= topY + 30);
            if (!band.length) return null;
            const centerX = band.reduce((sum, p) => sum + p.x, 0) / band.length;
            return { topY, centerX, count: band.length };
        }

        function drawLoadVisual() {
            if (!isSimulating || env.load <= 0) return;
            const top = getTopCluster();
            if (!top) return;

            const plateW = Math.max(120, Math.min(280, 110 + env.load * 1.4));
            const plateH = 16;
            const plateX = top.centerX - plateW / 2;
            const plateY = Math.max(30, top.topY - 26);

            const blockW = Math.max(90, plateW * 0.65);
            const blockH = 24 + env.load * 0.7;
            const blockX = top.centerX - blockW / 2;
            const blockY = plateY - blockH - 18;

            ctx.fillStyle = 'rgba(52, 73, 94, 0.95)';
            ctx.fillRect(blockX, blockY, blockW, blockH);
            ctx.strokeStyle = '#1f2d3a';
            ctx.lineWidth = 2;
            ctx.strokeRect(blockX, blockY, blockW, blockH);

            ctx.fillStyle = '#ecf0f1';
            ctx.font = 'bold 14px Segoe UI';
            ctx.textAlign = 'center';
            ctx.fillText(`${env.load}kg`, top.centerX, blockY + blockH / 2 + 5);

            ctx.strokeStyle = 'rgba(60, 60, 60, 0.9)';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(top.centerX, blockY + blockH);
            ctx.lineTo(top.centerX, plateY);
            ctx.stroke();

            ctx.fillStyle = 'rgba(30, 30, 30, 0.9)';
            for (let i = -2; i <= 2; i++) {
                const x = top.centerX + i * (plateW / 6);
                ctx.beginPath();
                ctx.moveTo(x, plateY - 6);
                ctx.lineTo(x - 6, plateY - 16 - env.load * 0.08);
                ctx.lineTo(x + 6, plateY - 16 - env.load * 0.08);
                ctx.closePath();
                ctx.fill();
            }

            ctx.fillStyle = 'rgba(127, 140, 141, 0.95)';
            ctx.fillRect(plateX, plateY, plateW, plateH);
            ctx.strokeStyle = '#5d6d6d';
            ctx.lineWidth = 2;
            ctx.strokeRect(plateX, plateY, plateW, plateH);
        }

        function drawGrid() {
            ctx.strokeStyle = "rgba(0,0,0,0.06)";
            ctx.lineWidth = 1;
            for(let x=0; x<width; x+=40) { ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,height); ctx.stroke(); }
            for(let y=height; y>0; y-=40) { ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(width,y); ctx.stroke(); }
        }

        function drawInteraction() {
            hoveredPoint = null;
            let minDist = CONFIG.snapDist;
            for (let p of points) {
                if (p.broken) continue;
                let d = Math.hypot(p.x - mouse.x, p.y - mouse.y);
                if (d < minDist) { minDist = d; hoveredPoint = p; }
            }

            if (deleteMode) {
                canvas.style.cursor = "cell";
                if (hoveredPoint) {
                    ctx.beginPath(); ctx.arc(hoveredPoint.x, hoveredPoint.y, 12, 0, Math.PI*2);
                    ctx.strokeStyle = "#e74c3c";
                    ctx.lineWidth = 3; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                }
            } else {
                if (hoveredPoint) {
                    ctx.beginPath(); ctx.arc(hoveredPoint.x, hoveredPoint.y, 12, 0, Math.PI*2);
                    ctx.strokeStyle = MATERIALS[currentMat].color; 
                    ctx.lineWidth = 2; ctx.setLineDash([2,2]); ctx.stroke(); ctx.setLineDash([]);
                    canvas.style.cursor = "pointer";
                } else if (mouse.y >= groundY - 10) {
                    canvas.style.cursor = "cell";
                } else {
                    canvas.style.cursor = "default";
                }
            }

            if (isDragging && dragStart && !deleteMode) {
                let targetX = hoveredPoint ? hoveredPoint.x : mouse.x;
                let targetY = hoveredPoint ? hoveredPoint.y : mouse.y;

                let dx = targetX - dragStart.x;
                let dy = targetY - dragStart.y;
                let dist = Math.hypot(dx, dy);
                let segments = Math.ceil(dist / CONFIG.maxStickLen);

                ctx.beginPath();
                ctx.moveTo(dragStart.x, dragStart.y);
                ctx.lineTo(targetX, targetY);
                ctx.strokeStyle = MATERIALS[currentMat].color;
                ctx.lineWidth = 3;
                ctx.setLineDash([5, 5]);
                ctx.stroke();
                ctx.setLineDash([]);

                if (segments > 1) {
                    ctx.fillStyle = "#e67e22";
                    ctx.font = "12px Arial";
                    ctx.fillText(`${segments}æ®µè¿æ¥`, mouse.x + 10, mouse.y);
                }
            }
        }

        // --- é¼ æ ‡äº‹ä»¶ ---
        canvas.addEventListener('mousemove', e => {
            const rect = canvas.getBoundingClientRect();
            mouse.x = e.clientX - rect.left;
            mouse.y = e.clientY - rect.top;
        });

        canvas.addEventListener('mousedown', e => {
            if (isSimulating) { showToast("âš ï¸ æµ‹è¯•ä¸­æ— æ³•ä¿®æ”¹ï¼Œè¯·å…ˆåœæ­¢ï¼"); return; }
            if (e.button === 2) return;

            if (deleteMode) {
                if (hoveredPoint) {
                    saveHistory();
                    deletePoint(hoveredPoint);
                    showToast("åˆ é™¤èŠ‚ç‚¹");
                } else if (hoveredStick) {
                    saveHistory();
                    deleteStick(hoveredStick);
                    showToast("åˆ é™¤æ†ä»¶");
                }
                return;
            }

            if (hoveredPoint) {
                dragStart = hoveredPoint;
                isDragging = true;
            } else if (mouse.y > groundY - 15) {
                let p = addPoint(mouse.x, groundY, true, currentMat);
                dragStart = p;
                isDragging = true;
            }
        });

        canvas.addEventListener('mouseup', e => {
            if (isSimulating || deleteMode) return;
            if (!isDragging || !dragStart) return;

            let endP = hoveredPoint;
            let finalX = endP ? endP.x : mouse.x;
            let finalY = endP ? endP.y : mouse.y;
            if (!endP && finalY > groundY) finalY = groundY;

            let dx = finalX - dragStart.x;
            let dy = finalY - dragStart.y;
            let dist = Math.hypot(dx, dy);

            if (dist > 5) {
                saveHistory();

                let segments = Math.ceil(dist / CONFIG.maxStickLen);
                let currentStart = dragStart;

                for (let i = 1; i <= segments; i++) {
                    let isLast = (i === segments);
                    let nextP;

                    if (isLast && endP) {
                        nextP = endP;
                    } else {
                        let ratio = i / segments;
                        let nx = dragStart.x + dx * ratio;
                        let ny = dragStart.y + dy * ratio;
                        let pin = (isLast && ny >= groundY - 1);
                        if (pin) ny = groundY;
                        nextP = addPoint(nx, ny, pin, currentMat);
                    }

                    if (currentStart !== nextP) {
                        let exists = sticks.some(s => (s.p1 === currentStart && s.p2 === nextP) || (s.p1 === nextP && s.p2 === currentStart));
                        if (!exists) sticks.push(new Stick(currentStart, nextP, currentMat));
                    }
                    currentStart = nextP;
                }
            }
            isDragging = false;
            dragStart = null;
        });

        canvas.addEventListener('contextmenu', e => {
            e.preventDefault();
            if (isSimulating) return;
            if (!deleteMode && hoveredPoint) {
                saveHistory();
                deletePoint(hoveredPoint);
                showToast("åˆ é™¤èŠ‚ç‚¹");
            }
        });

        // --- è“å›¾å­˜å‚¨ ---
        function saveBlueprint() {
            let savedPoints = points.map(p => ({
                x: p.x, y: p.y, pinned: p.pinned, matId: p.mat.id
            }));
            let savedSticks = sticks.map(s => ({
                p1_idx: points.indexOf(s.p1),
                p2_idx: points.indexOf(s.p2),
                matId: s.mat.id
            }));
            blueprint = { points: savedPoints, sticks: savedSticks };
        }

        function restoreBlueprint() {
            if (!blueprint) return;
            // ä¿å­˜æ–­è£‚ä¿¡æ¯ï¼ˆwasBroken å’Œ breakOrderï¼‰ä»¥ä¾¿æ¢å¤åæ ‡æ³¨
            let oldBrokenInfo = points.map(p => ({ wasBroken: p.wasBroken, breakOrder: p.breakOrder }));
            let oldStickBroken = sticks.map(s => ({ wasBroken: s.wasBroken, breakOrder: s.breakOrder }));

            points = [];
            sticks = [];
            blueprint.points.forEach(bp => addPoint(bp.x, bp.y, bp.pinned, bp.matId));
            blueprint.sticks.forEach(bs => {
                if (points[bs.p1_idx] && points[bs.p2_idx]) {
                    sticks.push(new Stick(points[bs.p1_idx], points[bs.p2_idx], bs.matId));
                }
            });

            // æ¢å¤æ–­è£‚ä¿¡æ¯
            for (let i = 0; i < points.length && i < oldBrokenInfo.length; i++) {
                points[i].wasBroken = oldBrokenInfo[i].wasBroken;
                points[i].breakOrder = oldBrokenInfo[i].breakOrder;
            }
            for (let i = 0; i < sticks.length && i < oldStickBroken.length; i++) {
                sticks[i].wasBroken = oldStickBroken[i].wasBroken;
                sticks[i].breakOrder = oldStickBroken[i].breakOrder;
            }
        }

        function hasAnyBroken() {
            for (let p of points) if (p.broken) return true;
            for (let s of sticks) if (s.broken) return true;
            return false;
        }

        // --- å…¨å±€å‡½æ•° ---
        window.setMaterial = (matId) => {
            currentMat = matId;
            document.querySelectorAll('.mat-option').forEach(el => el.classList.remove('active'));
            document.getElementById('mat-' + matId).classList.add('active');
            showToast(`å·²åˆ‡æ¢ææ–™ä¸ºï¼š${MATERIALS[matId].name}`);
        };

        window.updateEnv = (type, val) => {
            env[type] = parseInt(val);
            let text = val;
            if (type === 'wind' || type === 'quake') text += "çº§";
            if (type === 'load') text += "kg";
            document.getElementById(`val-${type}`).innerText = text;
        };

        window.toggleSimulation = () => {
            const btn = document.getElementById('btn-mode');
            const sliders = document.querySelectorAll('input[type=range]');

            if (!isSimulating) {
                // å¼€å§‹æµ‹è¯•ï¼šæ¸…é™¤æ‰€æœ‰å†å²æ–­è£‚æ ‡è®°ï¼ˆwasBroken å’Œ breakOrderï¼‰ï¼Œç¡®ä¿ä»å¹²å‡€çŠ¶æ€å¼€å§‹
                points.forEach(p => { p.wasBroken = false; p.breakOrder = 0; });
                sticks.forEach(s => { s.wasBroken = false; s.breakOrder = 0; });
                if (hasAnyBroken()) {
                    restoreBlueprint(); // ä½† blueprint åº”è¯¥ä¹Ÿæ˜¯å¹²å‡€çš„ï¼Œå› ä¸º wasBroken å·²æ¸…
                }
                saveBlueprint();
                nextBreakOrder = 1;
                points.forEach(p => { p.broken = false; });
                sticks.forEach(s => { s.broken = false; });
                angleConstraints = [];
                buildAngleConstraints();
                isSimulating = true;
                preheatRemaining = 40;
                btn.innerHTML = "â¹ï¸ åœæ­¢æµ‹è¯•";
                btn.classList.add('testing');
                sliders.forEach(s => s.disabled = false);
                showToast("æµ‹è¯•å¼€å§‹ï¼šç»“æ„æ­£åœ¨ç¼“æ…¢ç¨³å®šä¸­...");
            } else {
                restoreBlueprint();
                isSimulating = false;
                preheatRemaining = 0;
                angleConstraints = [];
                btn.innerHTML = "â–¶ï¸ å¼€å§‹æµ‹è¯•";
                btn.classList.remove('testing');
                sliders.forEach(s => { s.value = 0; s.disabled = true; });
                env = { wind: 0, quake: 0, load: 0 };
                document.getElementById('val-wind').innerText = "0çº§";
                document.getElementById('val-quake').innerText = "0çº§";
                document.getElementById('val-load').innerText = "0kg";
                // å¦‚æœæ²¡æœ‰æ–°æ–­è£‚ï¼Œåˆ™æ‰€æœ‰ wasBroken ä¸º falseï¼Œä¸ä¼šæ˜¾ç¤ºçº¢è‰²ï¼›å¦‚æœæœ‰ï¼Œåˆ™æ˜¾ç¤º
                showToast("åœºæ™¯å·²å¤åŸ");
            }
        };

        window.clearAll = () => {
            if (isSimulating) return;
            if (confirm("ç¡®å®šè¦æ¸…ç©ºæ‰€æœ‰è®¾è®¡å—ï¼Ÿ")) {
                points = []; sticks = [];
                init();
                blueprint = null;
                nextBreakOrder = 1;
                saveHistory();
                showToast("å·²æ¸…ç©º");
            }
        };

        window.undo = () => {
            undo();
        };

        window.toggleDeleteMode = () => {
            toggleDeleteMode();
        };

        window.autoConnectIntersections = () => {
            autoConnectIntersections();
        };

        function showToast(msg) {
            let t = document.getElementById('toast');
            if (t) {
                t.innerText = msg;
                t.style.opacity = 1;
                setTimeout(() => t.style.opacity = 0, 2000);
            }
        }

        function updateStats() {
            const getEl = (id) => document.getElementById(id);
            
            let maxH = 0;
            points.forEach(p => {
                if (!p.broken) maxH = Math.max(maxH, groundY - p.y);
            });
            let elHeight = getEl('stat-height');
            if (elHeight) elHeight.innerText = Math.round(maxH / CONFIG.scale) + " cm";

            let nodeCount = points.filter(p=>!p.broken).length;
            let elNodes = getEl('stat-nodes');
            if (elNodes) elNodes.innerText = nodeCount;

            let lenWood = 0, lenSteel = 0, lenCarbon = 0;
            sticks.forEach(s => {
                if (!s.broken && !s.p1.broken && !s.p2.broken) {
                    let l = s.len / CONFIG.scale;
                    if (s.mat.id === 'wood') lenWood += l;
                    else if (s.mat.id === 'steel') lenSteel += l;
                    else if (s.mat.id === 'carbon') lenCarbon += l;
                }
            });

            let elLenWood = getEl('stat-len-wood');
            if (elLenWood) elLenWood.innerText = Math.round(lenWood);
            let elLenSteel = getEl('stat-len-steel');
            if (elLenSteel) elLenSteel.innerText = Math.round(lenSteel);
            let elLenCarbon = getEl('stat-len-carbon');
            if (elLenCarbon) elLenCarbon.innerText = Math.round(lenCarbon);

            let totalLength = lenWood + lenSteel + lenCarbon;
            let elTotalLen = getEl('stat-total-length');
            if (elTotalLen) elTotalLen.innerText = Math.round(totalLength);

            let cost = nodeCount * CONFIG.nodeBaseCost + lenWood*2 + lenSteel*8 + lenCarbon*20;
            let elCost = getEl('stat-cost');
            if (elCost) elCost.innerText = Math.round(cost);
        }

        init();
    })();
</script>
</body>
</html>
