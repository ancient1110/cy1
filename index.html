<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>å¡”å°å·¥ç¨‹æ¨¡æ‹Ÿå™¨</title>
    <style>
        body { font-family: 'Segoe UI', 'Microsoft YaHei', sans-serif; margin: 0; overflow: hidden; background: #f0f2f5; display: flex; user-select: none; }

        #canvas-container {
            flex-grow: 1; height: 100vh; position: relative;
            background: radial-gradient(circle at center, #fff 0%, #eef2f3 100%);
            cursor: crosshair;
        }

        #sidebar {
            width: 310px; height: 100vh; background: #fff;
            border-left: 1px solid #ddd; display: flex; flex-direction: column;
            box-shadow: -4px 0 12px rgba(0,0,0,0.06); z-index: 100; flex-shrink: 0;
        }
        .sidebar-scroll { padding: 12px 14px; overflow-y: auto; flex-grow: 1; }

        h2 { font-size: 13px; color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 4px; margin: 14px 0 8px; }
        h2:first-child { margin-top: 0; }

        .mode-btn {
            width: 100%; padding: 11px; border: none; border-radius: 8px;
            font-size: 15px; font-weight: bold; cursor: pointer; color: #fff;
            background: linear-gradient(135deg, #2ecc71, #27ae60);
            box-shadow: 0 4px 10px rgba(46,204,113,0.35); margin-bottom: 10px; transition: all .2s;
        }
        .mode-btn.running {
            background: linear-gradient(135deg, #e74c3c, #c0392b);
            box-shadow: 0 4px 10px rgba(231,76,60,0.35);
        }
        .mode-btn:active { transform: scale(0.98); }

        .mat-row { display: flex; gap: 6px; margin-bottom: 8px; }
        .mat-card {
            flex: 1; padding: 7px 3px; border: 2px solid #eee; border-radius: 6px;
            text-align: center; cursor: pointer; font-size: 11px; background: #fafafa; transition: .15s;
        }
        .mat-card:hover { border-color: #bbb; }
        .mat-card.active { border-color: #3498db; background: #ebf5fb; color: #2980b9; font-weight: bold; }

        .slider-box { background: #f8f9fa; border-radius: 6px; padding: 6px 8px; margin-bottom: 6px; }
        .slider-label { display: flex; justify-content: space-between; font-size: 12px; color: #555; margin-bottom: 3px; }
        input[type=range] { width: 100%; cursor: pointer; accent-color: #3498db; }

        .stat-row { display: flex; justify-content: space-between; font-size: 12px; margin-bottom: 5px; color: #555; }
        .total-cost { display: flex; justify-content: space-between; align-items: baseline; font-size: 20px; color: #e67e22; font-weight: bold; margin-top: 8px; }

        .btn-row { display: flex; gap: 6px; margin-top: 8px; }
        .btn-s {
            flex: 1; background: #ecf0f1; border: none; padding: 7px 0;
            border-radius: 4px; cursor: pointer; font-size: 12px; color: #555;
        }
        .btn-s:hover { background: #ffeaa7; color: #d35400; }
        .btn-s.danger { background: #fde6e6; color: #c0392b; }
        .btn-s.danger:hover { background: #f5b7b1; }

        #btn-del {
            width: 100%; margin-top: 6px; padding: 7px; background: #ecf0f1;
            border: 2px solid #bdc3c7; border-radius: 4px; cursor: pointer; font-size: 12px;
        }
        #btn-del.active { background: #e74c3c; border-color: #c0392b; color: #fff; }

        .btn-special {
            width: 100%; margin-top: 8px; padding: 8px; background: #3498db;
            color: #fff; border: none; border-radius: 4px; cursor: pointer; font-size: 13px;
        }
        .btn-special:hover { background: #2980b9; }

        #toast {
            position: absolute; top: 18px; left: 50%; transform: translateX(-50%);
            background: rgba(44,62,80,.88); color: #fff; padding: 8px 18px;
            border-radius: 30px; opacity: 0; transition: opacity .4s; pointer-events: none; font-size:13px;
        }
        #height-indicator {
            position: absolute; top: 12px; left: 14px;
            background: rgba(255,255,255,.92); color: #2c3e50;
            border: 1px solid #d5d8dc; border-radius: 10px; padding: 7px 12px;
            font-size: 13px; font-weight: 600; pointer-events: none;
            box-shadow: 0 3px 8px rgba(0,0,0,.08);
        }
        #replay-banner {
            position: absolute; bottom: 70px; left: 50%; transform: translateX(-50%);
            background: rgba(231,76,60,.9); color: #fff; padding: 8px 18px;
            border-radius: 20px; font-size: 13px; display: none;
        }
    </style>
</head>
<body>

<div id="canvas-container">
    <canvas id="simCanvas"></canvas>
    <div id="toast"></div>
    <div id="height-indicator">ğŸ”ï¸ æœ€é«˜ç‚¹ï¼š0 cm</div>
    <div id="replay-banner">ğŸ” å¤ç›˜æ¨¡å¼ï¼šçº¢è‰²æ ‡è®°ä¸ºæœ€å…ˆæ–­è£‚å¤„</div>
</div>

<div id="sidebar">
    <div class="sidebar-scroll">
        <button id="btn-mode" class="mode-btn" onclick="toggleSim()">â–¶ï¸ å¼€å§‹æµ‹è¯•</button>

        <h2>ğŸ—ï¸ ææ–™é€‰æ‹©</h2>
        <div class="mat-row">
            <div class="mat-card active" onclick="setMat(0)" id="mat-0">
                <div style="width:10px;height:10px;background:#8e44ad;border-radius:50%;margin:0 auto 4px"></div>
                æœ¨æ¡<br>Â¥2/cm
            </div>
            <div class="mat-card" onclick="setMat(1)" id="mat-1">
                <div style="width:10px;height:10px;background:#2c3e50;border-radius:50%;margin:0 auto 4px"></div>
                é’¢ç®¡<br>Â¥8/cm
            </div>
            <div class="mat-card" onclick="setMat(2)" id="mat-2">
                <div style="width:10px;height:10px;background:#2980b9;border-radius:50%;margin:0 auto 4px"></div>
                ç¢³çº¤<br>Â¥20/cm
            </div>
        </div>

        <h2>ğŸ›ï¸ ç¯å¢ƒè½½è·</h2>
        <div class="slider-box">
            <div class="slider-label"><span>ğŸ’¨ é£åŠ›</span><span id="disp-wind">0çº§</span></div>
            <input type="range" id="range-wind" min="0" max="100" value="0" disabled oninput="setEnv('wind',this.value)">
        </div>
        <div class="slider-box">
            <div class="slider-label"><span>ğŸŒ‹ åœ°éœ‡</span><span id="disp-quake">0çº§</span></div>
            <input type="range" id="range-quake" min="0" max="100" value="0" disabled oninput="setEnv('quake',this.value)">
        </div>
        <div class="slider-box">
            <div class="slider-label"><span>âš–ï¸ é¡¶éƒ¨å‹é‡</span><span id="disp-load">0kg</span></div>
            <input type="range" id="range-load" min="0" max="100" value="0" disabled oninput="setEnv('load',this.value)">
        </div>

        <h2>ğŸ“Š å·¥ç¨‹é€ ä»·å•</h2>
        <div class="stat-row"><span>èŠ‚ç‚¹æ•°:</span><span id="count-node">0</span> Ã— Â¥50</div>
        <div class="stat-row"><span>æ†ä»¶æ€»é•¿:</span><span id="stat-total-len">0 cm</span></div>
        <div class="stat-row"><span>æœ¨æ¡:</span><span id="stat-len-wood">0 cm</span> (Â¥2)</div>
        <div class="stat-row"><span>é’¢ç®¡:</span><span id="stat-len-steel">0 cm</span> (Â¥8)</div>
        <div class="stat-row"><span>ç¢³çº¤:</span><span id="stat-len-carbon">0 cm</span> (Â¥20)</div>
        <div class="stat-row"><span>æœ€å¤§åº”åŠ›:</span><span id="max-stress">0%</span></div>
        <div class="total-cost"><span>æ€»ä»·:</span><span>Â¥<span id="cost-total">0</span></span></div>

        <div class="btn-row">
            <button class="btn-s" onclick="undo()">â†©ï¸ æ’¤é”€</button>
            <button class="btn-s danger" onclick="clearAll()">ğŸ—‘ï¸ æ¸…ç©º</button>
        </div>
        <button id="btn-del" onclick="toggleDel()">âœ‚ï¸ åˆ é™¤æ¨¡å¼ï¼šå…³é—­</button>
        <button class="btn-special" onclick="autoConnect()">ğŸ”— è‡ªåŠ¨è¿æ¥äº¤å‰ç‚¹</button>
    </div>
</div>

<script>
// ===== ç‰©ç†é…ç½® =====
const PHYSICS = {
    subSteps: 20,
    gravity: 0.15,
    groundY: 0,
    scale: 50.0,
    snap: 12,
    damping: 0.98,
};

const MATERIALS = [
    { name:'æœ¨æ¡', cost:2,  color:'#8e44ad', stiffness:0.25, density:0.3,  strength:0.12 },
    { name:'é’¢ç®¡', cost:8,  color:'#2c3e50', stiffness:0.60, density:2.0,  strength:0.35 },
    { name:'ç¢³çº¤', cost:20, color:'#2980b9', stiffness:0.70, density:0.1,  strength:0.30 },
];

// ===== å…¨å±€çŠ¶æ€ =====
let state = {
    simulating: false,
    nodes: [], sticks: [], bends: [],
    warmupFrames: 0,
    matIdx: 0,
    env: { wind:0, quake:0, load:0 },
    mouse: {x:0,y:0},
    dragging: false, dragStart: null,
    hoverNode: null, hoverStick: null,
    deleting: false,
    history: [],
    blueprint: null,      // æ¨¡æ‹Ÿå‰å¿«ç…§
    breakLog: [],         // æ–­è£‚è®°å½•ï¼ˆç”¨äºå¤ç›˜ï¼‰
    nextBreakOrder: 1,
    statsLocked: false,   // æ¨¡æ‹Ÿä¸­é”å®šé€ ä»·ç»Ÿè®¡
};

// ===== ç¢ç‰‡ç‰¹æ•ˆ =====
let fragments = [];
function createExplosion(x, y, color='#e67e22') {
    for (let i=0; i<8; i++) fragments.push({
        x, y, color,
        vx:(Math.random()-.5)*8, vy:(Math.random()-.5)*8-2,
        life:1.0, size:Math.random()*3+2
    });
}
function updateFragments() {
    fragments.forEach(f => {
        f.x += f.vx; f.y += f.vy;
        f.vy += 0.4; // é‡åŠ›
        f.life -= 0.025;
        ctx.globalAlpha = f.life;
        ctx.fillStyle = f.color;
        ctx.fillRect(f.x, f.y, f.size, f.size);
    });
    ctx.globalAlpha = 1;
    fragments = fragments.filter(f => f.life > 0);
}

// ===== Node ç±» =====
class Node {
    constructor(x, y, pinned, matIdx=0) {
        this.x = x; this.y = y;
        this.oldX = x; this.oldY = y;
        this.baseX = x; // åœ°éœ‡ç”¨ï¼šè®°å½•åˆå§‹X
        this.pinned = pinned;
        this.matIdx = matIdx;
        this.mass = 1;
        this.forceX = 0; this.forceY = 0;
        this.id = Math.random();
        this.broken = false;
        this.wasBroken = false; this.breakOrder = 0; // å¤ç›˜ç”¨
    }

    update() {
        if (this.pinned) {
            // åœ°éœ‡ï¼šè®©å›ºå®šèŠ‚ç‚¹æŒ¯åŠ¨
            if (state.env.quake > 0) {
                let t = Date.now();
                let xAmp = state.env.quake / 5;
                let yAmp = state.env.quake / 8;
                this.x = this.baseX + Math.sin(t/50) * xAmp;
                this.y = PHYSICS.groundY + Math.cos(t/65) * yAmp;
            } else {
                this.x = this.baseX;
                this.y = PHYSICS.groundY;
            }
            this.oldX = this.x; this.oldY = this.y;
            return;
        }
        let vx = (this.x - this.oldX) * PHYSICS.damping;
        let vy = (this.y - this.oldY) * PHYSICS.damping;
        this.oldX = this.x; this.oldY = this.y;
        let ax = this.forceX / this.mass;
        let ay = this.forceY / this.mass;
        this.x += vx + ax * 0.125 * 0.125;
        this.y += vy + ay * 0.125 * 0.125;
        if (this.y > PHYSICS.groundY) {
            this.y = PHYSICS.groundY;
            this.oldY = this.y + vy * 0.5;
        }
        this.forceX = 0; this.forceY = 0;
    }
}

// ===== Stick ç±» =====
class Stick {
    constructor(n1, n2, matIdx) {
        this.n1 = n1; this.n2 = n2;
        this.mat = MATERIALS[matIdx];
        this.matIdx = matIdx;
        this.len = Math.hypot(n1.x-n2.x, n1.y-n2.y);
        this.stress = 0;
        this.broken = false;
        this.id = Math.random();
        this.wasBroken = false; this.breakOrder = 0;
    }

    getMass() { return (this.len/PHYSICS.scale)*this.mat.density; }

    solve() {
        if (this.broken) return;
        let dx = this.n2.x-this.n1.x, dy = this.n2.y-this.n1.y;
        let currLen = Math.hypot(dx, dy);
        if (currLen === 0) return;
        let diff = currLen - this.len;
        // æ¯æ¬¡è¿­ä»£ç´¯ç§¯|correction|ï¼Œæ€»ç´¯ç§¯é‡æ­£æ¯”äºçº¦æŸåŠ›ï¼ˆXPBDçš„Lagrangeä¹˜å­ï¼‰
        // æ¯”"ä¿®æ­£å‰æœ€å¤§å€¼"æ›´å‡†ç¡®ï¼šä¸¤æ®µç­‰é•¿æ†å—ç›¸åŒè½´åŠ›æ—¶ç´¯ç§¯é‡ç›¸åŒ
        this.stress += diff / this.len / PHYSICS.subSteps;

        let offX = (dx/currLen)*diff*0.5, offY = (dy/currLen)*diff*0.5;
        if (!this.n1.pinned && !this.n2.pinned) {
            this.n1.x+=offX; this.n1.y+=offY; this.n1.oldX+=offX; this.n1.oldY+=offY;
            this.n2.x-=offX; this.n2.y-=offY; this.n2.oldX-=offX; this.n2.oldY-=offY;
        } else if (!this.n1.pinned) {
            this.n1.x+=offX*2; this.n1.y+=offY*2; this.n1.oldX+=offX*2; this.n1.oldY+=offY*2;
        } else if (!this.n2.pinned) {
            this.n2.x-=offX*2; this.n2.y-=offY*2; this.n2.oldX-=offX*2; this.n2.oldY-=offY*2;
        }
    }

    draw() {
        if (this.broken) return;
        let dx = this.n2.x-this.n1.x, dy = this.n2.y-this.n1.y;
        let len = Math.hypot(dx, dy);
        if (len === 0) return;

        // å¤ç›˜é«˜äº®
        if (!state.simulating && this.wasBroken && this.breakOrder > 0 && this.breakOrder <= 3) {
            ctx.beginPath();
            ctx.strokeStyle = '#e74c3c'; ctx.lineWidth = 6;
            ctx.moveTo(this.n1.x, this.n1.y); ctx.lineTo(this.n2.x, this.n2.y); ctx.stroke();
        }

        // æ†ä»¶æœ¬ä½“ï¼šå§‹ç»ˆç”¨ææ–™åŸè‰²
        ctx.beginPath();
        ctx.strokeStyle = this.mat.color;
        ctx.lineWidth = 3; ctx.lineCap = 'round';
        ctx.moveTo(this.n1.x, this.n1.y); ctx.lineTo(this.n2.x, this.n2.y); ctx.stroke();

        // æ¨¡æ‹Ÿä¸­ï¼šåœ¨æ†ä»¶æ—è¾¹ç”»åº”åŠ›ç»†çº¿
        if (state.simulating && Math.abs(this.stress) > 0.001) {
            let ratio = Math.max(-1, Math.min(1, this.stress / this.mat.strength));
            let stressColor = ratio > 0
                ? `rgba(220, 50, 50, ${Math.abs(ratio) * 0.85})`   // æ‹‰ä¼¸çº¢
                : `rgba(50, 100, 220, ${Math.abs(ratio) * 0.85})`; // å‹ç¼©è“
            // å‚ç›´åç§»4px
            let nx = -(dy/len)*4, ny = (dx/len)*4;
            ctx.beginPath();
            ctx.strokeStyle = stressColor;
            ctx.lineWidth = 1.5; ctx.lineCap = 'round';
            ctx.moveTo(this.n1.x+nx, this.n1.y+ny);
            ctx.lineTo(this.n2.x+nx, this.n2.y+ny);
            ctx.stroke();
        }
    }
}

// ===== BendConstraint =====
class BendConstraint {
    constructor(a, b, c, s1, s2) {
        this.a=a; this.b=b; this.c=c; this.s1=s1; this.s2=s2;
        this.targetAngle = this._angle();
        this.valid = true;
    }
    _angle() {
        let ax=this.a.x-this.b.x, ay=this.a.y-this.b.y;
        let cx=this.c.x-this.b.x, cy=this.c.y-this.b.y;
        return Math.atan2(ay,ax) - Math.atan2(cy,cx);
    }
    solve() {
        if (this.s1.broken || this.s2.broken) return;
        if (this.a.broken || this.b.broken || this.c.broken) return;
        let ax=this.a.x-this.b.x, ay=this.a.y-this.b.y;
        let cx=this.c.x-this.b.x, cy=this.c.y-this.b.y;
        let la=Math.hypot(ax,ay), lc=Math.hypot(cx,cy);
        if (la<0.001||lc<0.001) return;
        let curAngle = Math.atan2(ay,ax)-Math.atan2(cy,cx);
        let diff = curAngle - this.targetAngle;
        while(diff>Math.PI) diff-=2*Math.PI;
        while(diff<-Math.PI) diff+=2*Math.PI;
        if (Math.abs(diff)<0.0001) return;
        // åˆå§‹è§’æ¥è¿‘180Â°ï¼ˆç›´çº¿èŠ‚ç‚¹ï¼Œå³æ†ä»¶ä¸­é—´æ’å…¥çš„èŠ‚ç‚¹ï¼‰ç”¨æ›´é«˜åˆšæ€§
        // è¿™ç±»èŠ‚ç‚¹ä»£è¡¨"è¿ç»­æ†ä»¶"ï¼Œå¿…é¡»å¼ºåŠ›é˜»æ­¢å¼¯æŠ˜
        let baseK = (this.s1&&this.s2) ? (this.s1.mat.stiffness+this.s2.mat.stiffness)*0.5 : 0.3;
        let angleDev = Math.abs(Math.abs(this.targetAngle) - Math.PI); // åç¦»180Â°çš„ç¨‹åº¦
        let isStraight = angleDev < 0.3; // åˆå§‹æ¥è¿‘ç›´çº¿
        let k = isStraight ? Math.max(baseK, 0.6) : baseK; // ç›´çº¿èŠ‚ç‚¹å¼ºåˆ¶è‡³å°‘0.6åˆšæ€§
        let half = diff*k*0.5;
        let cosH=Math.cos(-half),sinH=Math.sin(-half);
        let nax=ax*cosH-ay*sinH, nay=ax*sinH+ay*cosH;
        let ccosH=Math.cos(half),csinH=Math.sin(half);
        let ncx=cx*ccosH-cy*csinH, ncy=cx*csinH+cy*ccosH;
        if (!this.a.pinned) {
            let mx=(this.b.x+nax)-this.a.x, my=(this.b.y+nay)-this.a.y;
            this.a.x+=mx; this.a.y+=my; this.a.oldX+=mx; this.a.oldY+=my;
        }
        if (!this.c.pinned) {
            let mx=(this.b.x+ncx)-this.c.x, my=(this.b.y+ncy)-this.c.y;
            this.c.x+=mx; this.c.y+=my; this.c.oldX+=mx; this.c.oldY+=my;
        }
    }
}

// ===== ä¸»ç¨‹åº =====
const canvas = document.getElementById('simCanvas');
const ctx = canvas.getContext('2d');

function init() {
    resize();
    window.addEventListener('resize', resize);
    addNode(canvas.width/2-60, PHYSICS.groundY, true);
    addNode(canvas.width/2+60, PHYSICS.groundY, true);
    saveHistory();
    loop();
}

function resize() {
    canvas.width = document.getElementById('canvas-container').offsetWidth;
    canvas.height = document.getElementById('canvas-container').offsetHeight;
    PHYSICS.groundY = canvas.height - 60;
    state.nodes.forEach(n => { if(n.pinned){ n.y=PHYSICS.groundY; n.baseX=n.x; } });
}

function addNode(x, y, pinned=false, matIdx=null) {
    let n = new Node(x, y, pinned, matIdx!=null?matIdx:state.matIdx);
    state.nodes.push(n);
    return n;
}

function buildBends() {
    state.bends = [];
    state.nodes.forEach(b => {
        let connected = state.sticks.filter(s => !s.broken && (s.n1===b||s.n2===b));
        for (let i=0;i<connected.length;i++) for (let j=i+1;j<connected.length;j++) {
            let a = connected[i].n1===b ? connected[i].n2 : connected[i].n1;
            let c = connected[j].n1===b ? connected[j].n2 : connected[j].n1;
            let bc = new BendConstraint(a, b, c, connected[i], connected[j]);
            if (bc.valid) state.bends.push(bc);
        }
    });
}

// ===== å‹é‡å¯è§†åŒ– =====
function drawLoadVisual() {
    if (!state.simulating || state.env.load <= 0) return;
    let active = state.nodes.filter(n => !n.broken);
    if (!active.length) return;
    let topY = Math.min(...active.map(n=>n.y));
    let band = active.filter(n=>n.y<=topY+30);
    if (!band.length) return;
    let cx = band.reduce((s,n)=>s+n.x,0)/band.length;
    let load = state.env.load;
    let plateW = Math.max(100, Math.min(260, 100+load*1.4));
    let plateH = 14;
    let plateX = cx-plateW/2, plateY = Math.max(30, topY-24);
    let blockW = Math.max(80, plateW*0.6);
    let blockH = 20+load*0.7;
    let blockX = cx-blockW/2, blockY = plateY-blockH-16;

    ctx.fillStyle='rgba(52,73,94,0.95)'; ctx.fillRect(blockX,blockY,blockW,blockH);
    ctx.fillStyle='#ecf0f1'; ctx.font='bold 13px Segoe UI'; ctx.textAlign='center';
    ctx.fillText(`${load}kg`, cx, blockY+blockH/2+5);
    ctx.strokeStyle='rgba(60,60,60,.9)'; ctx.lineWidth=2.5; ctx.beginPath();
    ctx.moveTo(cx,blockY+blockH); ctx.lineTo(cx,plateY); ctx.stroke();
    ctx.fillStyle='rgba(127,140,141,.95)'; ctx.fillRect(plateX,plateY,plateW,plateH);
    ctx.strokeStyle='#888'; ctx.lineWidth=1; ctx.strokeRect(plateX,plateY,plateW,plateH);
    ctx.textAlign='left';
}

// ===== ä¸»å¾ªç¯ =====
function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    // åœ°é¢
    ctx.fillStyle = '#95a5a6';
    ctx.fillRect(0, PHYSICS.groundY, canvas.width, canvas.height-PHYSICS.groundY);

    drawGrid();

    if (state.simulating) {
        // è´¨é‡åˆå§‹åŒ–
        state.nodes.forEach(n => n.mass=0.5);
        state.sticks.forEach(s => {
            if (!s.broken) {
                s.stress = 0;
                let m=s.getMass()/2;
                s.n1.mass+=m; s.n2.mass+=m;
            }
        });
        // å½’ä¸€åŒ–ï¼šä¸­é—´èŠ‚ç‚¹è¿æ¥å¤šæ ¹æ†ï¼Œè´¨é‡ç­‰æ¯”ç¼©å‡ï¼Œé¿å…ä¸­é—´èŠ‚ç‚¹è¿‡é‡å¯¼è‡´å·®å¼‚åº”åŠ›
        state.nodes.forEach(n => {
            if (!n.pinned) {
                let conn = state.sticks.filter(s=>!s.broken&&(s.n1===n||s.n2===n)).length;
                if (conn > 1) n.mass = n.mass / Math.sqrt(conn); // sqrtç¼©å‡ï¼Œä¿ç•™éƒ¨åˆ†è´¨é‡å·®å¼‚ä½†ä¸è¿‡åˆ†
            }
        });

        // é¡¶éƒ¨å‹é‡
        let active = state.nodes.filter(n=>!n.pinned&&!n.broken);
        if (active.length>0 && state.env.load>0) {
            let topNode = active.reduce((a,b)=>a.y<b.y?a:b);
            topNode.forceY += state.env.load*9.8;
        }

        // é‡åŠ›
        active.forEach(n => n.forceY += PHYSICS.gravity*n.mass*50);

        // é£åŠ›ï¼šæ€»åŠ› = windÃ—ç»“æ„é«˜åº¦ï¼ŒæŒ‰é«˜åº¦æƒé‡åˆ†é…
        if (state.env.wind>0 && active.length>0) {
            let windDir = Math.sin(Date.now()/500);
            let topY = Math.min(...active.map(n=>n.y));
            let structH = PHYSICS.groundY - topY;
            if (structH>0) {
                let totalWind = windDir*state.env.wind*2.0*structH/500;
                let heights = active.map(n=>Math.max(0,PHYSICS.groundY-n.y));
                let sumH = heights.reduce((a,b)=>a+b,0);
                active.forEach((n,i) => n.forceX += totalWind*(heights[i]/sumH));
            }
        }

        // ç§¯åˆ†
        state.nodes.forEach(n => n.update());

        // çº¦æŸè¿­ä»£
        for (let i=0; i<PHYSICS.subSteps; i++) {
            state.bends.forEach(b => b.solve());
            state.sticks.forEach(s => s.solve());
            state.bends.forEach(b => b.solve());
        }

        // é¢„çƒ­ç»“æŸååˆ¤æ–­ç ´æ–­
        state.warmupFrames++;
        if (state.warmupFrames > 30) {
            // æ†ä»¶æ–­è£‚
            state.sticks.forEach(s => {
                if (!s.broken && Math.abs(s.stress)>s.mat.strength) {
                    s.broken = true;
                    if (!state.breakLog.find(l=>l.type==='stick'&&l.id===s.id)) {
                        state.breakLog.push({type:'stick',id:s.id,order:state.nextBreakOrder++});
                        createExplosion((s.n1.x+s.n2.x)/2,(s.n1.y+s.n2.y)/2,s.mat.color);
                    }
                }
            });

            // å­¤ç«‹èŠ‚ç‚¹æ¸…ç†
            state.nodes.filter(n=>!n.pinned&&!n.broken).forEach(n => {
                let conn = state.sticks.filter(s=>!s.broken&&(s.n1===n||s.n2===n)).length;
                if (conn===0) { n.broken=true; createExplosion(n.x,n.y,'#888'); }
            });
        }
    }

    // ç»˜åˆ¶å‹é‡
    drawLoadVisual();

    // ç»˜åˆ¶æ†ä»¶
    state.sticks.forEach(s => s.draw());

    // æ‚¬åœæ†ä»¶é«˜äº®
    if (!state.simulating && !state.deleting && state.hoverStick && !state.hoverNode) {
        ctx.strokeStyle='#2ecc71'; ctx.lineWidth=7; ctx.globalAlpha=0.45;
        ctx.beginPath();
        ctx.moveTo(state.hoverStick.n1.x,state.hoverStick.n1.y);
        ctx.lineTo(state.hoverStick.n2.x,state.hoverStick.n2.y);
        ctx.stroke(); ctx.globalAlpha=1;
        let proj=getProjectedPoint(state.mouse,state.hoverStick.n1,state.hoverStick.n2);
        ctx.beginPath(); ctx.arc(proj.x,proj.y,6,0,Math.PI*2);
        ctx.fillStyle='#2ecc71'; ctx.fill();
    }

    // ç»˜åˆ¶èŠ‚ç‚¹
    state.nodes.forEach(n => {
        if (n.broken) return;
        // å¤ç›˜é«˜äº®
        if (!state.simulating && n.wasBroken && n.breakOrder>0 && n.breakOrder<=3) {
            ctx.beginPath(); ctx.arc(n.x,n.y,12,0,Math.PI*2);
            ctx.strokeStyle='#e74c3c'; ctx.lineWidth=3; ctx.stroke();
        }
        ctx.beginPath(); ctx.arc(n.x,n.y,n.pinned?8:5,0,Math.PI*2);
        ctx.fillStyle = n.pinned ? '#34495e' : MATERIALS[n.matIdx].color;
        ctx.fill();
        ctx.strokeStyle='rgba(255,255,255,.5)'; ctx.lineWidth=1; ctx.stroke();
    });

    // æ‹–æ‹½é¢„è§ˆï¼ˆå¸¦åˆ†æ®µæç¤ºï¼‰
    if (state.dragging && state.dragStart) {
        let dest = state.hoverNode || state.mouse;
        if (!state.hoverNode && state.hoverStick)
            dest = getProjectedPoint(state.mouse,state.hoverStick.n1,state.hoverStick.n2);
        ctx.beginPath(); ctx.moveTo(state.dragStart.x,state.dragStart.y);
        ctx.lineTo(dest.x,dest.y);
        ctx.strokeStyle=MATERIALS[state.matIdx].color; ctx.lineWidth=2.5;
        ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
    }

    // åˆ é™¤æ¨¡å¼æ‚¬åœ
    if (state.deleting && !state.simulating) {
        if (state.hoverStick) {
            ctx.beginPath();
            ctx.moveTo(state.hoverStick.n1.x,state.hoverStick.n1.y);
            ctx.lineTo(state.hoverStick.n2.x,state.hoverStick.n2.y);
            ctx.strokeStyle='#e67e22'; ctx.lineWidth=8;
            ctx.setLineDash([5,5]); ctx.stroke(); ctx.setLineDash([]);
        }
        if (state.hoverNode) {
            ctx.beginPath(); ctx.arc(state.hoverNode.x,state.hoverNode.y,13,0,Math.PI*2);
            ctx.strokeStyle='#e74c3c'; ctx.lineWidth=3; ctx.setLineDash([3,3]); ctx.stroke(); ctx.setLineDash([]);
        }
    }

    updateFragments();
    updateStats();
    requestAnimationFrame(loop);
}

// ===== è“å›¾ï¼ˆå¤ç›˜ç³»ç»Ÿï¼‰=====
function saveBlueprint() {
    state.blueprint = {
        nodes: state.nodes.map(n=>({x:n.x,y:n.y,pinned:n.pinned,matIdx:n.matIdx,id:n.id})),
        sticks: state.sticks.map(s=>({n1:s.n1.id,n2:s.n2.id,matIdx:s.matIdx,id:s.id}))
    };
}

function restoreBlueprint() {
    if (!state.blueprint) return;
    fragments = [];
    state.nodes = state.blueprint.nodes.map(d=>{
        let n=new Node(d.x,d.y,d.pinned,d.matIdx); n.id=d.id; return n;
    });
    state.sticks = state.blueprint.sticks.map(d=>{
        let n1=state.nodes.find(n=>n.id===d.n1);
        let n2=state.nodes.find(n=>n.id===d.n2);
        if (!n1||!n2) return null;
        let s=new Stick(n1,n2,d.matIdx); s.id=d.id; return s;
    }).filter(Boolean);
    // æŠŠ breakLog åº”ç”¨å›æ¥ï¼Œç”¨äºå¤ç›˜é«˜äº®
    state.breakLog.forEach(log => {
        if (log.type==='stick') {
            let s=state.sticks.find(s=>s.id===log.id);
            if (s) { s.wasBroken=true; s.breakOrder=log.order; }
        } else {
            let n=state.nodes.find(n=>n.id===log.id);
            if (n) { n.wasBroken=true; n.breakOrder=log.order; }
        }
    });
    state.bends = [];
}

// ===== å†å²è®°å½• =====
function saveHistory() {
    if (state.history.length>=20) state.history.shift();
    state.history.push({
        nodes: state.nodes.map(n=>({x:n.x,y:n.y,pinned:n.pinned,matIdx:n.matIdx,id:n.id})),
        sticks: state.sticks.map(s=>({n1:s.n1.id,n2:s.n2.id,matIdx:s.matIdx}))
    });
}

window.undo = () => {
    if (state.simulating) return toast("æµ‹è¯•ä¸­ä¸èƒ½æ’¤é”€");
    if (state.history.length<=1) return toast("æ²¡æœ‰æ›´å¤šæ­¥éª¤");
    state.history.pop();
    let prev=state.history[state.history.length-1];
    state.nodes = prev.nodes.map(d=>{let n=new Node(d.x,d.y,d.pinned,d.matIdx);n.id=d.id;return n;});
    state.sticks = prev.sticks.map(d=>{
        let n1=state.nodes.find(n=>n.id===d.n1), n2=state.nodes.find(n=>n.id===d.n2);
        if(n1&&n2) return new Stick(n1,n2,d.matIdx);
    }).filter(Boolean);
    state.bends=[];
    // æ¢å¤åæ¸…ç†å­¤ç«‹èŠ‚ç‚¹ï¼ˆå¿«ç…§é—´ä¸­é—´çŠ¶æ€å¯èƒ½äº§ç”Ÿå­¤å„¿ï¼‰
    state.nodes = state.nodes.filter(n => n.pinned || state.sticks.some(s => s.n1===n || s.n2===n));
    toast("æ’¤é”€æˆåŠŸ");
};

// ===== æ¨¡æ‹Ÿå¼€å…³ =====
window.toggleSim = () => {
    let btn=document.getElementById('btn-mode');
    let ranges=document.querySelectorAll('input[type=range]');
    let banner=document.getElementById('replay-banner');

    if (!state.simulating) {
        // å¼€å§‹
        state.statsLocked = true;
        saveBlueprint();
        state.breakLog=[]; state.nextBreakOrder=1; fragments=[];
        state.nodes.forEach(n=>{n.broken=false;n.wasBroken=false;n.breakOrder=0;});
        state.sticks.forEach(s=>{s.broken=false;s.wasBroken=false;s.breakOrder=0;});
        // æ¸…é›¶é€Ÿåº¦
        state.nodes.forEach(n=>{n.oldX=n.x;n.oldY=n.y;n.forceX=0;n.forceY=0;});
        buildBends();
        state.warmupFrames=0;
        state.simulating=true;
        btn.textContent='â¹ï¸ åœæ­¢æµ‹è¯•'; btn.className='mode-btn running';
        ranges.forEach(r=>r.disabled=false);
        banner.style.display='none';
        toast("æµ‹è¯•å¼€å§‹");
    } else {
        // åœæ­¢ â†’ å¤ç›˜
        state.statsLocked=false;
        state.simulating=false;
        ranges.forEach(r=>{r.value=0;r.disabled=true;});
        state.env={wind:0,quake:0,load:0};
        ['wind','quake','load'].forEach(k=>{
            document.getElementById('disp-'+k).innerText='0'+(k==='load'?'kg':'çº§');
        });
        restoreBlueprint();
        btn.textContent='â–¶ï¸ å¼€å§‹æµ‹è¯•'; btn.className='mode-btn';
        if (state.breakLog.length>0) {
            banner.style.display='block';
            toast("å¤ç›˜æ¨¡å¼ï¼šçº¢è‰²æ ‡è®°ä¸ºæœ€å…ˆæ–­è£‚å¤„");
        }
    }
};

// ===== å…¶ä»–å·¥å…· =====
window.setMat = (idx) => {
    state.matIdx=idx;
    document.querySelectorAll('.mat-card').forEach((el,i)=>
        el.className=i===idx?'mat-card active':'mat-card');
};

window.setEnv = (key, val) => {
    state.env[key]=parseInt(val);
    let suffix = key==='load'?'kg':'çº§';
    document.getElementById('disp-'+key).innerText=val+suffix;
};

window.toggleDel = () => {
    state.deleting=!state.deleting;
    let btn=document.getElementById('btn-del');
    btn.textContent=state.deleting?'âœ‚ï¸ åˆ é™¤æ¨¡å¼ï¼šå¼€å¯':'âœ‚ï¸ åˆ é™¤æ¨¡å¼ï¼šå…³é—­';
    btn.className=state.deleting?'active':'';
};

window.clearAll = () => {
    if (state.simulating) return;
    if (!confirm('ç¡®å®šæ¸…ç©ºæ‰€æœ‰è®¾è®¡ï¼Ÿ')) return;
    state.nodes=[]; state.sticks=[]; fragments=[]; state.breakLog=[];
    document.getElementById('replay-banner').style.display='none';
    init();
    toast("å·²æ¸…ç©º");
};

// ===== è‡ªåŠ¨è¿æ¥äº¤å‰ç‚¹ï¼ˆå®Œæ•´ç®—æ³•ï¼‰=====
window.autoConnect = () => {
    if (state.simulating) return toast("æµ‹è¯•ä¸­ä¸èƒ½ä½¿ç”¨");
    if (state.sticks.length<2) return toast("è‡³å°‘éœ€è¦ä¸¤æ ¹æ†ä»¶");
    saveHistory();
    const EPS=1e-4, EP_GUARD=0.02, MERGE_TOL=Math.max(2,PHYSICS.snap*0.25);
    const clusters=[], splitMap=new Map();

    function ptLineDist(px,py,ax,ay,bx,by) {
        let vx=bx-ax,vy=by-ay,l2=vx*vx+vy*vy;
        if(l2<EPS) return Math.hypot(px-ax,py-ay);
        let t=Math.max(0,Math.min(1,((px-ax)*vx+(py-ay)*vy)/l2));
        return Math.hypot(px-(ax+t*vx),py-(ay+t*vy));
    }
    function findNearNode(ix,iy,s1,s2) {
        let best=null,bd=PHYSICS.snap;
        for(let p of state.nodes) {
            let d=Math.hypot(p.x-ix,p.y-iy); if(d>=bd) continue;
            if(ptLineDist(p.x,p.y,s1.n1.x,s1.n1.y,s1.n2.x,s1.n2.y)>MERGE_TOL) continue;
            if(ptLineDist(p.x,p.y,s2.n1.x,s2.n1.y,s2.n2.x,s2.n2.y)>MERGE_TOL) continue;
            best=p;bd=d;
        }
        return best;
    }
    function findOrMakeCluster(x,y,existing) {
        for(let c of clusters) {
            if(Math.hypot(c.x-x,c.y-y)<=MERGE_TOL) {
                if(!c.existing&&existing) c.existing=existing;
                if(c.existing){c.x=c.existing.x;c.y=c.existing.y;}
                return c;
            }
        }
        let c={x:existing?existing.x:x,y:existing?existing.y:y,existing,node:null};
        clusters.push(c); return c;
    }
    function regSplit(s,t,c) {
        if(t<=EP_GUARD||t>=1-EP_GUARD) return;
        if(!splitMap.has(s)) splitMap.set(s,[]);
        splitMap.get(s).push({t,c});
    }

    for(let i=0;i<state.sticks.length;i++) for(let j=i+1;j<state.sticks.length;j++) {
        let s1=state.sticks[i],s2=state.sticks[j];
        if(s1.n1===s2.n1||s1.n1===s2.n2||s1.n2===s2.n1||s1.n2===s2.n2) continue;
        let denom=(s2.n2.y-s2.n1.y)*(s1.n2.x-s1.n1.x)-(s2.n2.x-s2.n1.x)*(s1.n2.y-s1.n1.y);
        if(Math.abs(denom)<EPS) continue;
        let ua=((s2.n2.x-s2.n1.x)*(s1.n1.y-s2.n1.y)-(s2.n2.y-s2.n1.y)*(s1.n1.x-s2.n1.x))/denom;
        let ub=((s1.n2.x-s1.n1.x)*(s1.n1.y-s2.n1.y)-(s1.n2.y-s1.n1.y)*(s1.n1.x-s2.n1.x))/denom;
        if(ua<=EP_GUARD||ua>=1-EP_GUARD||ub<=EP_GUARD||ub>=1-EP_GUARD) continue;
        let ix=s1.n1.x+ua*(s1.n2.x-s1.n1.x), iy=s1.n1.y+ua*(s1.n2.y-s1.n1.y);
        let near=findNearNode(ix,iy,s1,s2);
        let cl=findOrMakeCluster(ix,iy,near);
        regSplit(s1,ua,cl); regSplit(s2,ub,cl);
    }

    let newNodes=0,procSticks=0;
    clusters.forEach(c=>{
        c.node=c.existing||addNode(c.x,c.y,false,state.matIdx);
        if(!c.existing) newNodes++;
    });
    for(let [stick,splits] of splitMap.entries()) {
        if(!splits.length) continue;
        splits.sort((a,b)=>a.t-b.t);
        let deduped=[]; for(let s of splits){
            let last=deduped[deduped.length-1];
            if(last&&Math.abs(last.t-s.t)<EP_GUARD) continue; deduped.push(s);
        }
        if(!deduped.length) continue;
        let idx=state.sticks.indexOf(stick); if(idx===-1) continue;
        state.sticks.splice(idx,1);
        let chain=[stick.n1,...deduped.map(s=>s.c.node),stick.n2];
        for(let i=0;i<chain.length-1;i++) {
            let a=chain[i],b=chain[i+1];
            if(a===b||Math.hypot(a.x-b.x,a.y-b.y)<0.5) continue;
            state.sticks.push(new Stick(a,b,stick.matIdx));
        }
        procSticks++;
    }
    if(newNodes>0||procSticks>0) toast(`è¿æ¥å®Œæˆï¼š${procSticks}æ ¹æ†ï¼Œ${newNodes}ä¸ªèŠ‚ç‚¹`);
    else toast("æœªå‘ç°äº¤å‰ç‚¹");
    saveHistory();
};

// ===== ç»Ÿè®¡æ›´æ–° =====
function updateStats() {
    let maxH=0;
    state.nodes.forEach(n=>{ if(!n.broken) maxH=Math.max(maxH,PHYSICS.groundY-n.y); });
    document.getElementById('height-indicator').textContent=`ğŸ”ï¸ æœ€é«˜ç‚¹ï¼š${Math.round(maxH/PHYSICS.scale*10)} cm`;

    if (state.statsLocked) {
        // æ¨¡æ‹Ÿä¸­åªæ›´æ–°åº”åŠ›
        let maxS=0;
        state.sticks.forEach(s=>{ if(!s.broken) maxS=Math.max(maxS,Math.abs(s.stress)); });
        document.getElementById('max-stress').textContent=(maxS*100).toFixed(1)+'%';
        return;
    }

    document.getElementById('count-node').textContent=state.nodes.length;
    let lW=0,lS=0,lC=0;
    state.sticks.forEach(s=>{
        let l=s.len/PHYSICS.scale;
        if(s.matIdx===0) lW+=l;
        else if(s.matIdx===1) lS+=l;
        else lC+=l;
    });
    document.getElementById('stat-len-wood').textContent=Math.round(lW)+' cm';
    document.getElementById('stat-len-steel').textContent=Math.round(lS)+' cm';
    document.getElementById('stat-len-carbon').textContent=Math.round(lC)+' cm';
    document.getElementById('stat-total-len').textContent=Math.round(lW+lS+lC)+' cm';
    let cost=state.nodes.length*50+lW*2+lS*8+lC*20;
    document.getElementById('cost-total').textContent=Math.round(cost);

    let maxS=0;
    state.sticks.forEach(s=>{ if(!s.broken) maxS=Math.max(maxS,Math.abs(s.stress)); });
    document.getElementById('max-stress').textContent=(maxS*100).toFixed(1)+'%';
}

// ===== ç½‘æ ¼ =====
function drawGrid() {
    ctx.strokeStyle='rgba(0,0,0,0.05)'; ctx.lineWidth=1;
    for(let x=0;x<canvas.width;x+=40){ctx.beginPath();ctx.moveTo(x,0);ctx.lineTo(x,canvas.height);ctx.stroke();}
    for(let y=canvas.height;y>0;y-=40){ctx.beginPath();ctx.moveTo(0,y);ctx.lineTo(canvas.width,y);ctx.stroke();}
}

// ===== å·¥å…·å‡½æ•° =====
function getProjectedPoint(p,v,w) {
    let l2=(v.x-w.x)**2+(v.y-w.y)**2;
    if(l2===0) return {x:v.x,y:v.y};
    let t=Math.max(0,Math.min(1,((p.x-v.x)*(w.x-v.x)+(p.y-v.y)*(w.y-v.y))/l2));
    return{x:v.x+t*(w.x-v.x),y:v.y+t*(w.y-v.y)};
}
function ptSegDist(p,a,b) {
    let proj=getProjectedPoint(p,a,b);
    return Math.hypot(p.x-proj.x,p.y-proj.y);
}
function getHoverNode(x,y) {
    let best=null,bd=PHYSICS.snap;
    for(let n of state.nodes){let d=Math.hypot(n.x-x,n.y-y);if(d<bd){bd=d;best=n;}}
    return best;
}
function getNearestStick(p) {
    let best=null,bd=12;
    for(let s of state.sticks){let d=ptSegDist(p,s.n1,s.n2);if(d<bd){bd=d;best=s;}}
    return best;
}

function toast(msg) {
    let t=document.getElementById('toast');
    t.textContent=msg; t.style.opacity=1;
    setTimeout(()=>t.style.opacity=0,2000);
}

// ===== é¼ æ ‡äº‹ä»¶ =====
canvas.addEventListener('mousemove', e => {
    let r=canvas.getBoundingClientRect();
    state.mouse={x:e.clientX-r.left,y:e.clientY-r.top};
    state.hoverNode=getHoverNode(state.mouse.x,state.mouse.y);
    state.hoverStick=!state.hoverNode?getNearestStick(state.mouse):null;
    if (state.deleting) canvas.style.cursor='cell';
    else if (state.hoverNode||state.hoverStick) canvas.style.cursor='pointer';
    else if (state.mouse.y>=PHYSICS.groundY-15) canvas.style.cursor='cell';
    else canvas.style.cursor='crosshair';
});

canvas.addEventListener('mousedown', e => {
    if (e.button===2) {
        // å³é”®åˆ é™¤
        if (state.simulating) return;
        if (state.hoverNode) {
            let pinnedCount = state.nodes.filter(n=>n.pinned).length;
            if (state.hoverNode.pinned && pinnedCount <= 2) return toast("è‡³å°‘ä¿ç•™2ä¸ªåœ°åŸºèŠ‚ç‚¹");
            saveHistory();
            state.sticks=state.sticks.filter(s=>s.n1!==state.hoverNode&&s.n2!==state.hoverNode);
            state.nodes=state.nodes.filter(n=>n!==state.hoverNode);
            state.nodes=state.nodes.filter(n=>n.pinned||state.sticks.some(s=>s.n1===n||s.n2===n));
            toast("åˆ é™¤èŠ‚ç‚¹");
        }
        return;
    }
    if (state.simulating) return toast("æµ‹è¯•ä¸­æ— æ³•ä¿®æ”¹");
    if (state.deleting) {
        if (state.hoverNode) {
            let pinnedCount = state.nodes.filter(n=>n.pinned).length;
            if (state.hoverNode.pinned && pinnedCount <= 2) return toast("è‡³å°‘ä¿ç•™2ä¸ªåœ°åŸºèŠ‚ç‚¹");
            saveHistory();
            state.sticks=state.sticks.filter(s=>s.n1!==state.hoverNode&&s.n2!==state.hoverNode);
            state.nodes=state.nodes.filter(n=>n!==state.hoverNode);
            state.nodes=state.nodes.filter(n=>n.pinned||state.sticks.some(s=>s.n1===n||s.n2===n));
            toast("åˆ é™¤èŠ‚ç‚¹");
        } else if (state.hoverStick) {
            saveHistory();
            state.sticks=state.sticks.filter(s=>s!==state.hoverStick);
            // æ¸…ç†å› åˆ æ†è€Œäº§ç”Ÿçš„å­¤ç«‹èŠ‚ç‚¹
            state.nodes=state.nodes.filter(n=>n.pinned||state.sticks.some(s=>s.n1===n||s.n2===n));
            toast("åˆ é™¤æ†ä»¶");
        }
        return;
    }
    if (state.hoverNode) {
        state.dragging=true; state.dragStart=state.hoverNode;
    } else if (state.hoverStick) {
        saveHistory();
        let proj=getProjectedPoint(state.mouse,state.hoverStick.n1,state.hoverStick.n2);
        let newN=addNode(proj.x,proj.y,false);
        let old=state.hoverStick;
        state.sticks=state.sticks.filter(s=>s!==old);
        state.sticks.push(new Stick(old.n1,newN,old.matIdx));
        state.sticks.push(new Stick(newN,old.n2,old.matIdx));
        state.dragging=true; state.dragStart=newN;
    } else if (state.mouse.y>PHYSICS.groundY-20) {
        let n=addNode(state.mouse.x,PHYSICS.groundY,true);
        state.dragging=true; state.dragStart=n;
    }
});

canvas.addEventListener('mouseup', e => {
    if (!state.dragging) return;
    let endNode=state.hoverNode;
    if (!endNode&&state.hoverStick) {
        let proj=getProjectedPoint(state.mouse,state.hoverStick.n1,state.hoverStick.n2);
        endNode=addNode(proj.x,proj.y,false);
        let old=state.hoverStick;
        state.sticks=state.sticks.filter(s=>s!==old);
        state.sticks.push(new Stick(old.n1,endNode,old.matIdx));
        state.sticks.push(new Stick(endNode,old.n2,old.matIdx));
    }
    if (!endNode) {
        let mx=state.mouse.x, my=state.mouse.y;
        if (my>PHYSICS.groundY-5) my=PHYSICS.groundY;
        endNode=addNode(mx,my,my>=PHYSICS.groundY);
    }
    if (state.dragStart!==endNode) {
        let exists=state.sticks.some(s=>(s.n1===state.dragStart&&s.n2===endNode)||(s.n1===endNode&&s.n2===state.dragStart));
        if (!exists) {
            saveHistory();
            state.sticks.push(new Stick(state.dragStart, endNode, state.matIdx));
        }
    }
    state.dragging=false; state.dragStart=null;
});

canvas.addEventListener('contextmenu',e=>e.preventDefault());

init();
</script>
</body>
</html>
